<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP和UDP的比较"><a href="#TCP和UDP的比较" class="headerlink" title="TCP和UDP的比较"></a>TCP和UDP的比较</h2><table><thead><tr><th>类型</th><th>是否面向连接</th><th>传输可靠性</th><th>传输形式</th><th>传输效率</th><th>需要资源</th><th>应用场景</th></tr></thead><tbody><tr><td>TCP</td><td>面向连接</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>要求通信数据可靠</td></tr><tr><td>UDP</td><td>无连接</td><td>不可靠</td><td>数据报文段</td><td>快</td><td>少</td><td>要求传输速度快</td></tr></tbody></table><h2 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h2><ol><li><strong>数据</strong>被分成若干TCP报文段</li><li><strong>TCP报文段</strong>首部包含32比特的序号字段和确认号字段。</li></ol><ul><li><pre><code>序号字段：TCP隐式地对数据流中的每一个字节编号</code></pre></li><li><pre><code>确认字段：填充期望收到的下一字节号</code></pre></li><li><pre><code>        TCP对确认的字段采取累积确认的方法</code></pre></li><li><pre><code>        对失序的报文段进行保留而不是直接丢弃</code></pre></li></ul><ol start="3"><li><strong>超时重传</strong></li></ol><ul><li>超时重传的时间间隔设置：TimeoutInterval=EstimatedRTT+4*DevRTT<ol><li>估算RTT 某一时刻测量报文段的RTT称为SampleRTT 其加权平均值为</li></ol>  EstimatedRTT=（1-α）* EstimatedRTT+α * SampleRTT （α一般为1/8)<ol start="2"><li>估算RTT的变化 DevRTT=（1-β）* DevRTT+β * |SampleRTT-EstimatedRTT|（β一般为1/4)</li></ol></li><li>定时器 使用单一的重传定时器</li><li>定时器启动条件：<ol><li>发送报文段且定时器未启动 </li><li>定时器超时重启，时间间隔翻倍 </li><li>收到ack</li></ol></li></ul><ol start="4"><li><strong>流量控制</strong> 流量控制服务是一个速度匹配服务，用于消除接收方缓存溢出的可能性</li><li>接收方维护一个接收缓存 大小为RcvBuffer</li><li>LastByteRead 接收端的应用进程从缓存中读取的最后一个字节的编号</li><li>LastByteRcvd 从网络中到达并由接收方接收的最后一个字节的编号</li><li>LastByteRcvd-LastByteRead≤RcvBuffer rwnd=RcvBuffer-（LastByteRcvd-LastByteRead）</li><li>发送方维护跟踪两个变量：LastByteSent 最后发送的字节编号 LastByteAcked 最后被确认的字节编号</li><li>LastByteSent-LastByteAcked≤rwnd</li><li>当rwnd=0时，发送方继续发送只有一个字节的数据，接收方返回确认报文</li></ol><p><img src="/img/network/1.jpg" alt="1"></p><ol start="5"><li><p><strong>拥塞控制</strong> 根据网络的拥塞情况而调整发送速度</p></li><li><p>端到端的拥塞控制：超时或3次冗余确认</p></li><li><p>网络辅助拥塞控制：路由器向发送方显示反馈网络拥塞状况</p><h3 id="如何限制发送速率，如何感知网络拥塞-如何改变发送速率"><a href="#如何限制发送速率，如何感知网络拥塞-如何改变发送速率" class="headerlink" title="如何限制发送速率，如何感知网络拥塞 如何改变发送速率"></a>如何限制发送速率，如何感知网络拥塞 如何改变发送速率</h3><ol><li><p>如何限制 LastByteSent-LastByteAcked≤min{cwnd,rwnd} (cwnd为发送方拥塞窗口大小)</p></li><li><p>如何感知 超时或3个冗余ACK</p></li><li><p>如何调整 TCP拥塞控制算法</p><p> 3.1  慢启动 指数增长</p><p> 3.2  拥塞避免 达到cwnd/2阈值 线性增长</p><p> 3.3  快恢复 </p></li></ol></li><li><p>差错恢复机制 TCP采取累积确认方式，接受方不会对正确但失序的报文段逐个确认</p></li></ol><h3 id="流水线的差错控制"><a href="#流水线的差错控制" class="headerlink" title="流水线的差错控制"></a>流水线的差错控制</h3><h4 id="回退N步（GBN"><a href="#回退N步（GBN" class="headerlink" title="回退N步（GBN)"></a>回退N步（GBN)</h4><h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><ol><li>累积确认</li><li>丢弃所有失序分组<h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5></li><li>超时重传所以已发送但还未确认的分组<h4 id="选择重传（SR）"><a href="#选择重传（SR）" class="headerlink" title="选择重传（SR）"></a>选择重传（SR）</h4><h5 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h5></li><li>逐个确认分组，失序分组进行缓存处理<h5 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h5></li><li>一分组一确认<h2 id="浏览器输入url地址回显页面过程"><a href="#浏览器输入url地址回显页面过程" class="headerlink" title="浏览器输入url地址回显页面过程"></a>浏览器输入url地址回显页面过程</h2><table><thead><tr><th>过程</th><th>协议</th></tr></thead><tbody><tr><td>浏览器查询域名的IP地址</td><td>DNS：获取域名对应IP</td></tr><tr><td>浏览器向web服务器发送一个http请求</td><td>TCP，IP,OPSF,ARP,HTTP</td></tr><tr><td>服务器处理请求</td><td></td></tr><tr><td>服务器返回一个html响应</td><td></td></tr><tr><td>浏览器回显html</td><td></td></tr></tbody></table></li></ol><h2 id="应用层：DNS"><a href="#应用层：DNS" class="headerlink" title="应用层：DNS"></a>应用层：DNS</h2><p>DNS提供将主机名转换为IP地址的目录服务，运行于UDP协议，端口为53号</p><h3 id="DNS服务器分类："><a href="#DNS服务器分类：" class="headerlink" title="DNS服务器分类："></a>DNS服务器分类：</h3><ul><li>根DNS服务器</li><li>顶级域DNS服务器</li><li>权威DNS服务器</li><li>本地服务器</li></ul><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><ol><li><p>递归：客户端只发一次请求，要求对方给出最终结果。</p></li><li><p>迭代：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，</p></li></ol><p>客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。<br>图示：<br><img src="/img/network/2.jpg"></p><p>3.实践中：从请求主机到本地DNS服务器是递归，其余查询是迭代的<br><img src="/img/network/3.jpg"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="数据平面-转发"><a href="#数据平面-转发" class="headerlink" title="数据平面-转发"></a>数据平面-转发</h3><p>作用：从其输入链路向其输出链路转发数据报</p><h4 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h4><h5 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h5><p>IP首部各字段：<br><img src="/img/network/4.jpg"><br>部分关键字段解释：</p><ul><li>版本号：规定IP协议版本</li><li>数据报长度：IP数据报总长度，理论长度为65535字节，实际小于等于1500字节</li><li>标识，标志，片偏移：与IP分片有关</li><li>生存时间：避免数据报在网络中永远循环，TTL减为0，数据报丢弃</li></ul><h5 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h5><ol><li>标识号：若路由器将一个数据报分为若干片时，接收端通过标识号判断哪些分片实际属于同一较大的数据报</li><li>标志：发送端将最后一个数据报的标志设为0，其余设为1<h3 id="控制平面-路由选择"><a href="#控制平面-路由选择" class="headerlink" title="控制平面-路由选择"></a>控制平面-路由选择</h3><h4 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h4></li><li>集中式路由选择算法-具有全局状态信息的算法被称作链路状态算法</li><li>Dijkstra算法</li><li>分散式路由选择算法，以迭代，分布式的方式计算最低开销路径</li><li>bellman-ford算法</li></ol><h4 id="自治系统（AS-内的路由选择协议-OSPF"><a href="#自治系统（AS-内的路由选择协议-OSPF" class="headerlink" title="自治系统（AS)内的路由选择协议-OSPF"></a>自治系统（AS)内的路由选择协议-OSPF</h4><ol><li>链路协议，洪泛链路状态信息和Dijkstra算法</li><li>优点</li><li>安全-能够鉴别OSPF路由器之间的交换</li><li>多条相同开销路径-</li><li>对单播和多播路由选择的综合支持</li><li>支持在单个AS中的层次结构-一个OSPF能够层次化地配置多个区域</li></ol><h4 id="AS之间的路由选择-BGP"><a href="#AS之间的路由选择-BGP" class="headerlink" title="AS之间的路由选择-BGP"></a>AS之间的路由选择-BGP</h4><ol><li>分布式和异步的协议</li><li>实现方式</li><li>从邻居AS获取前缀的可达性信息</li><li>确定到该前缀的”最好”路由<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="链路层寻址"><a href="#链路层寻址" class="headerlink" title="链路层寻址"></a>链路层寻址</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4></li><li>主机或路由器的适配器具有链路层地址而不是主机或路由器本身。<br>具有多个网络接口的主机或路由器将具有多个链路层地址</li><li>接受帧：</li><li>发送适配器将目的适配器的MAC地址插入该帧，并将该帧广播到局域网中，<br>局域网中各适配器接受并对比MAC地址，相同向上传递，不同则丢弃</li></ol><h4 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议-ARP"></a>地址解析协议-ARP</h4><ol><li>ARP为在同一子网内的主机和路由器接口解析IP地址</li><li>如何工作</li><li>每个主机或路由器在其内存中都有一个IP到MAC映射关系的ARP表<br>主机222.222.222.220一个可能的ARP表(TTL:该映射关系的时长，一般为20分钟)<table><thead><tr><th>IP地址</th><th>MAC地址</th><th>TTL</th></tr></thead><tbody><tr><td>222.222.222.221</td><td>88-B2-2f-54-1A-0F</td><td>13.45.00</td></tr><tr><td>222.222.222.223</td><td>5C-66-AB-90-75-B1</td><td>13.52.00</td></tr></tbody></table></li><li>主机向局域网广播目的主机的MAC地址，发送帧上插入下一跳的MAC地址</li></ol><h2 id="TCP连接-三次挥手和四次挥手"><a href="#TCP连接-三次挥手和四次挥手" class="headerlink" title="TCP连接-三次挥手和四次挥手"></a>TCP连接-三次挥手和四次挥手</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><ol><li>客户端的TCP向服务端的TCP发送一个特殊的TCP报文</li><li>不包含应用层数据</li><li>报文段首部标志位（SYN）设为1，并选择一个起始序号seq=client_isn</li><li>服务端接收到报文并发送SYNACK报文</li><li>提取TCP SYN报文段，为该TCP连接分配TCP缓存和变量</li><li>SYN设为1，确认号字段ack=client_isn 起始序号 seq=server_isn</li><li>客户端接收报文后</li><li>客户端分配TCP缓存和变量，连接建立，以后SYN标志号设为0</li></ol><h3 id="TCP关闭"><a href="#TCP关闭" class="headerlink" title="TCP关闭"></a>TCP关闭</h3><ol><li>客户端发送一个特殊的TCP报文段，FIN设为1</li><li>服务器接收后发送一个确认报文段，然后服务器发送终止报文段</li><li>客户端发送确认报文段，连接终止</li></ol><p>客户端状态：<br><img src="/img/network/5.jpg"></p><p>服务器端状态：<br><img src="/img/network/6.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>暑假总结</title>
    <link href="/2021/09/22/%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93/"/>
    <url>/2021/09/22/%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="暑假总结"><a href="#暑假总结" class="headerlink" title="暑假总结"></a>暑假总结</h1><p>大二升大三的暑假最后一天，没有疫情的话，8月15号就要开学实训的，然而南京突发疫情导致开学日期延至9月23号，总之又获得了一个漫长的暑假<br>明年暑假大概率是不回来了，或者考研或者实习，<br>中秋到现在已经放了自己四天了。想到今天是暑假最后一天，复盘一下自己的假期生活。<br>总结一下暑假的学习内容，总体还是没有达到预期的目标   <del>还是自己对自己要求太低</del></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>学习了spring+springMVC+Mybatis SSM框架 以及 springboot部分内容<br>并完成了一个ssm整合的小demo和仿天猫商城的ssm项目</p><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>跟着力扣刷题手册和代码随想录刷了200+的题，包括数组，回溯，排序，双指针，贪心，动归和二叉树</p><p>目前全部实现代码提交在github的<a href="https://github.com/nbyxs/LeetCode">LeetCode仓库</a></p><h2 id="项目整理"><a href="#项目整理" class="headerlink" title="项目整理"></a>项目整理</h2><ul><li>ssm的crud小demo</li><li>仿天猫官网的<a href="https://how2j.cn/k/tmall_ssm/tmall_ssm-1399/1399.html?p=187608">ssm项目</a></li><li>实训的<a href="https://github.com/LviatYi/AspirineManager">医药管理系统</a> （简单的页面跳转+crud，并且采用JWT进行身份验证，不过前端写的非常烂，<del>是的，就是我写的</del>，主要是学会了团队协作开发以及git的基本使用)</li></ul><h2 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h2><ol><li>《计算机网络自顶向下》 看到第四章 网络层 啃不动了，</li><li>《算法》 第四版 结合刷题选择性的看，看了排序，二叉树等章节</li><li>《二战历史年记》才看了前三章 23333</li></ol><h2 id="博客学习"><a href="#博客学习" class="headerlink" title="博客学习"></a>博客学习</h2><ul><li><a href="https://snailclimb.gitee.io/">JavaGuide的博客及面试整理</a><ul><li><pre><code>熟悉了java基础+集合+多线程</code></pre></li><li><pre><code>了解了JVM</code></pre></li><li><pre><code>复习了操作系统+计算机网络</code></pre></li><li><pre><code>了解了数据库事务和索引等内容</code></pre></li><li><pre><code>巩固spring框架的知识</code></pre></li></ul></li></ul><h2 id="下阶段的计划："><a href="#下阶段的计划：" class="headerlink" title="下阶段的计划："></a>下阶段的计划：</h2><ol><li>完成springboot以及redis学习，并完成在线教育的项目</li><li>复习刷过的题目，继续看面经</li><li>尝试找实习，寒假之前找不到就准备考研了</li><li>努力养成看书的习惯，大部头确实难啃，也许人与人的区分度就在这上面了。道理懂得都懂，实践就是另外一回事了。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>感谢我爸妈在我整个暑假基本宅在家里也没什么怨言 <del>虽然我也有做饭什么的，嘻嘻</del> 以后也许会离家的时间会越来越长，不太会有如此长的时间陪伴父母。</p><p>自认为并不是一个好学生，可能是周围环境没有压力，宛如温水煮青蛙，学习的动力只能靠自己自觉或ddl的临近。这样噩噩浑浑了两年，感觉自己学了点，但又不知道学了什么，更不知道学了怎么用。</p><p>这不是一个好现象，而且我认为这种现象在同龄人中不在少数。临近毕业才发现自己玩了四年，步入社会而没有准备好，随着潮流考公考研，想得很多却做得很少</p><p>一句话：”我没有准备好。”</p><p>当重拾起来的时候，发现面对庞大的知识体系无从下手，力不从心，最终无功而返，功败垂成，折戟沉沙或功败垂成，前功尽弃。却不曾想自己是在偿还四年欠下的债。</p><p>间接性踌躇满志，持续性混吃等死是人的通病。</p><p>知识学的越来越多，越感觉自己的渺小，越发战战兢兢，如履薄冰，如临深渊。</p><p>学习是终生的事情，懒惰是人的天性，也许换句话说 人的一生就是和懒惰抗争的一生？</p><p>认清现实，抛弃幻想，努力奋斗。</p><p>暂时扯这么多，以后想到的再补充吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring</title>
    <link href="/2021/09/18/spring/"/>
    <url>/2021/09/18/spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是 Spring仍然可以和其他的框架无缝整合。</p><h2 id="spring特征：轻量，控制反转，面向切面，容器，框架"><a href="#spring特征：轻量，控制反转，面向切面，容器，框架" class="headerlink" title="spring特征：轻量，控制反转，面向切面，容器，框架"></a>spring特征：轻量，控制反转，面向切面，容器，框架</h2><ul><li>控制反转（IOC）：控制反转原则（或DI，依赖注入）<br>  在此过程中，对象仅通过构造函数参数、工厂方法参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖项(即它们使用的其他对象)；<br>  从根本上说，这个过程是bean本身通过直接构造类或Service Locator模式等机制来控制依赖项的实例化或位置的相反过程(因此得名“控制反转”)。</li></ul><h2 id="spring核心组件："><a href="#spring核心组件：" class="headerlink" title="spring核心组件："></a>spring核心组件：</h2><p><img src="spring_files/1.jpg"></p><h2 id="spring常用模块："><a href="#spring常用模块：" class="headerlink" title="spring常用模块："></a>spring常用模块：</h2><p><img src="spring_files/2.jpg"></p><h2 id="spirng-IOC原理"><a href="#spirng-IOC原理" class="headerlink" title="spirng IOC原理"></a>spirng IOC原理</h2><p>spring IoC实现原理是工厂模式+反射机制</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务与索引整理</title>
    <link href="/2021/09/17/sql/"/>
    <url>/2021/09/17/sql/</url>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><p><strong>事务</strong>（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，<br>即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。<br>如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</p><h3 id="ACID事务特性："><a href="#ACID事务特性：" class="headerlink" title="ACID事务特性："></a>ACID事务特性：</h3><p>1、原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。<br>2、一致性或可串性：事务的执行使得数据库从一种正确状态转换成另一种正确状态<br>3、隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务<br>4、持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>√</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）</p><h3 id="并发事务可能带来的问题"><a href="#并发事务可能带来的问题" class="headerlink" title="并发事务可能带来的问题"></a>并发事务可能带来的问题</h3><p>1.<strong>脏读</strong>：事务对数据进行修改但未提交至数据库，另一个事务访问同一数据称为脏数据，依据该数据进行的操作可能是不正确的<br>2.<strong>丢失修改</strong>：两个事务同时对同一数据进行修改操作，第二个事务的修改结果可能会覆盖第一个事务的结果，造成修改数据错误<br>3.<strong>不可重复读</strong>：在一个事务多次访问同一数据的期间，另一个并发事务访问该数据并进行修改，可能导致该事务多次访问的数据不同<br>4.<strong>幻读</strong>：在一个事务多次查询特定记录期间，另一个并发事务插入了几条记录，可能导致该事务多次查询结果不相同</p><h3 id="大表优化方式："><a href="#大表优化方式：" class="headerlink" title="大表优化方式："></a>大表优化方式：</h3><ul><li>1.字段：<ul><li>1.1尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</li><li>1.2VARCHAR的长度只分配真正需要的空间</li><li>1.3使用枚举或整数代替字符串类型</li><li>1.4尽量使用TIMESTAMP而非DATETIME，</li><li>1.5单表不要有太多字段，建议在20以内</li><li>1.6避免使用NULL字段，很难查询优化且占用额外索引空间</li><li>1.7用整型来存IP</li></ul></li></ul><p>2.限定数据范围<br>3.读写分离：主库负责写，从库负责读<br>4.垂直分区：将数据表列拆分<br>5.水平分区：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><h3 id="简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别"><a href="#简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别" class="headerlink" title="简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别"></a>简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别</h3><ul><li>MyISAM： <ul><li>1.不支持事务，但是每次查询都是原子的；</li><li>2.支持表级锁，即每次操作是对整个表加锁；</li><li>3.存储表的总行数； </li><li>4.一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；</li><li>5.采用非聚集索引，索引文件的数据域存储指向数据文件的指针。</li><li>6.辅索引与主索引基本一致，但是辅索引不用保证唯一性。 </li></ul></li><li>InnoDb：<ul><li>1.支持 ACID 的事务，支持事务的四种隔离级别；</li><li>2.支持行级锁及外键约束：因此可以支持写并发；</li></ul></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h3 id="索引的目的是什么？"><a href="#索引的目的是什么？" class="headerlink" title="索引的目的是什么？"></a>索引的目的是什么？</h3><p>1.快速访问数据表中的特定信息，提高检索速度<br>2.创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>3.加速表和表之间的连接<br>4.使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</p><h3 id="索引对数据库系统的负面影响是什么？"><a href="#索引对数据库系统的负面影响是什么？" class="headerlink" title="索引对数据库系统的负面影响是什么？"></a>索引对数据库系统的负面影响是什么？</h3><p>负面影响：<br><strong>创建</strong>索引和维护索引需要耗费时间，这个时间随着<strong>数据量</strong>的增加而增加；<br>索引需要占用<strong>物理空间</strong>，不光是表需要占用数据空间，每个索引也需要占用物理空间；<br>当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p><h3 id="为数据表建立索引的原则有哪些？"><a href="#为数据表建立索引的原则有哪些？" class="headerlink" title="为数据表建立索引的原则有哪些？"></a>为数据表建立索引的原则有哪些？</h3><p>在最频繁使用的、用以缩小查询范围的字段上建立索引。<br>在频繁使用的、需要排序的字段上建立索引</p><h3 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h3><p>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。<br>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="什么是乐观锁"><a href="#什么是乐观锁" class="headerlink" title="什么是乐观锁"></a>什么是乐观锁</h3><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；<br>悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，</p><h4 id="乐观锁的实现方式："><a href="#乐观锁的实现方式：" class="headerlink" title="乐观锁的实现方式："></a>乐观锁的实现方式：</h4><p><strong>版本号</strong>：给数据增加一个版本标识，在数据库上就是表中增加一个version字段，<br>每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version，如果还是开始读取的version就可以更新了，<br>如果现在的version比老的version大，说明有其他事务更新了该数据，并增加了版本号，<br>这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理<br><strong>时间戳</strong>（timestamp）：和版本号基本一样，只是通过时间戳来判断而已，<br>注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。<br><strong>待更新字段</strong>：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息</p><h3 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁"></a>什么是悲观锁</h3><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，</p><h4 id="悲观锁按性质分："><a href="#悲观锁按性质分：" class="headerlink" title="悲观锁按性质分："></a>悲观锁按性质分：</h4><p>排他锁（x锁）：事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以<strong>同时读</strong>，但<strong>不能有写操作</strong>，直到A释放S锁。<br>共享锁（s锁）：事务A对对象T加X锁以后，其他事务<strong>不能对T加任何锁</strong>，只有事务A可以读写对象T直到A释放X锁。<br>更新锁（u锁）：用来预定要对此对象施加X锁，它<strong>允许其他事务读</strong>，但<strong>不允许再施加U锁或X锁</strong>；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的</p><h3 id="什么是行级锁"><a href="#什么是行级锁" class="headerlink" title="什么是行级锁"></a>什么是行级锁</h3><p>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时， Oracle 会自动应用行级锁：</p><ol><li>INSERT、 UPDATE、 DELETE、 SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</li><li>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</li><li>使用 COMMIT 或 ROLLBACK 语句释放锁。</li></ol><h3 id="什么是表级锁"><a href="#什么是表级锁" class="headerlink" title="什么是表级锁"></a>什么是表级锁</h3><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。<br>最常使用的MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 </p><h3 id="什么是页级锁"><a href="#什么是页级锁" class="headerlink" title="什么是页级锁"></a>什么是页级锁</h3><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。<strong>表级锁速度快，但冲突多，行级冲突少，但速度慢。</strong><br>所以取了折衷的页级，一次锁定相邻的一组记录。</p><h2 id="数据库三大范式："><a href="#数据库三大范式：" class="headerlink" title="数据库三大范式："></a>数据库三大范式：</h2><p>第一范式：<strong>属性</strong>不可分<br>第二范式：非主属性不存在对主键的<strong>部分依赖</strong><br>第三范式：非主属性不存在对主键的<strong>传递依赖</strong></p><h2 id="数据库索引："><a href="#数据库索引：" class="headerlink" title="数据库索引："></a>数据库索引：</h2><p>主键的作用：</p><p>1.可以保证实体的完整性；<br>2.能够加快数据库的操作速度；<br>3.确定数据唯一性<br>…</p><h3 id="为什么主键能加快数据库的操作速度？–-gt-为什么索引能加快数据库操作速度？"><a href="#为什么主键能加快数据库的操作速度？–-gt-为什么索引能加快数据库操作速度？" class="headerlink" title="为什么主键能加快数据库的操作速度？–&gt;为什么索引能加快数据库操作速度？"></a>为什么主键能加快数据库的操作速度？–&gt;为什么索引能加快数据库操作速度？</h3><p>在没有添加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列<br>如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，<br>也就是上面说的「B Tree/B+ Tree」结构，换句话说，就是整个表就变成了一个索引。<br><strong>主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。</strong></p><p>非聚簇索引与树结构无关，与树存放的内容有关；<br>1.data域存放的是数据记录的地址，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。<br>2.data域保存了完整的数据记录，这个索引的key是数据表的主键，这被称为“聚簇索引（或聚集索引）”。</p><p><img src="/img/1.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/16/hello-world/"/>
    <url>/2021/09/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/09/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/09/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统总结"><a href="#操作系统总结" class="headerlink" title="操作系统总结"></a>操作系统总结</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>概念：当一个进程在用户态执行一个用户程序时，需要一个系统服务，则必须执行一个陷阱或系统调用指令，将控制转移到操作系统。<br>操作系统通过参数查找<strong>需要系统调用</strong>的进程，为其执行系统调用，并把控制返回在系统调用后后面跟随着的指令。</p><p>翻译：学渣（用户态）在做作业（运行多个进程）时碰到不会做的题目<strong>寻求学霸帮忙</strong>（寻求帮助——系统调用），<br>学霸将作业接手（该进程陷入内核），此时学渣或等待其完成该题（下一道题可能需要这一题的结果——下一条指令需要这一条指令的执行结果） 或继续做下一道题（执行无关指令）</p><h3 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h3><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>pid=fork()</td><td>创建与父进程相同的子进程</td></tr><tr><td>pid=watipid(pid,&amp;statloc,options)</td><td>等待一个进程终止</td></tr><tr><td>s=execve(name,argv,environp)</td><td>替换一个进程核心映像</td></tr><tr><td>exit(status)</td><td>终止进程执行并返回结果</td></tr></tbody></table><h3 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h3><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>fd=open(file,how,…)</td><td>打开文件读写</td></tr><tr><td>s=close(fd)</td><td>关闭文件</td></tr><tr><td>n=read(fd,buffer,nbytes)</td><td>把数据从一个文件读到缓冲区</td></tr><tr><td>n=write(fd,buffer,nbytes)</td><td>把数据从缓冲区写回文件</td></tr><tr><td>position=Iseek(fd,offset,whence)</td><td>移动文件指针</td></tr><tr><td>s=stat(name,&amp;buf)</td><td>获取文件状态信息</td></tr></tbody></table><h3 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h3><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>s=mkmdir(name,mode)</td><td>创建一个新目录</td></tr><tr><td>s=rmdir(name,mode)</td><td>删除一个空目录</td></tr><tr><td>s=link(name1,name2)</td><td>创建一个新目录项name2并指向目录name1</td></tr><tr><td>s=unlink(name)</td><td>删除一个目录项</td></tr><tr><td>s=mount(special,name,flag)</td><td>安装一个文件系统</td></tr><tr><td>s=umount(special)</td><td>删除一个文件系统</td></tr></tbody></table><h3 id="各种系统调用"><a href="#各种系统调用" class="headerlink" title="各种系统调用"></a>各种系统调用</h3><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>s=chdir(dirname)</td><td>改变目录工程</td></tr><tr><td>s=chmod(name,mode)</td><td>修改一个文件的保护位</td></tr><tr><td>s=kill(pid,signal)</td><td>发送信号给一个进程</td></tr><tr><td>seconds=time(&amp;seconds)</td><td>自1970年1月1日流逝的时间</td></tr></tbody></table><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ol><li>概念：一个进程就是一个程序实例，包括程序计数器，寄存器和变量当前值<br>有程序，输入，输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法来切换进程<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4></li></ol><ul><li> 系统初始化</li><li> 正在运行的程序执行创建进程的系统调用</li><li> 用户请求创建进程</li><li> 批处理作业初始化</li></ul><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><ul><li> 正常退出</li><li> 出错退出</li><li> 严重错误</li><li> 被其他进程杀死<h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4></li><li> UNIX 进程和它所有的子进程共同组成一个进程组</li><li> Windows 所有进程地位相同，父进程拥有令牌（句柄）控制子进程 <h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3></li></ul><ol><li>理由</li></ol><ul><li> 线程并进程更轻量级</li><li> 平衡CPU处理和I/O处理</li><li> 将多个应用程序分解成准并行运行的多个顺序线程，程序设计模型会更简单</li></ul><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><strong>如何确保多个进程在关键活动中不会出现交叉？进程间信息是如何传递的？如何正确按序执行进程？</strong></p><h3 id="在共享内存实现互斥访问"><a href="#在共享内存实现互斥访问" class="headerlink" title="在共享内存实现互斥访问"></a>在共享内存实现互斥访问</h3><ol><li>屏蔽中断 每个进程在刚刚进入临界区屏蔽中断，离开打开中断</li><li>锁变量 锁变量0,1之间转换</li><li>严格轮转法 连续测试是否可以进入临界区 称为忙等待</li><li>Peterson解法</li><li>TSL指令</li><li>睡眠与唤醒</li><li>生产者-消费者问题 sleep和wakeup</li><li>信号量：取值可以为0(表示未保存的唤醒操作)或者为正值(表示有一个或多个唤醒操作)</li><li>down和up</li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><ul><li> 先来先服务</li><li> 最短作业优先</li><li> 最短剩余时间优先<h3 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h3></li><li> 轮转调度</li><li> 优先级调度</li><li> 多级队列</li><li> 最短进程优先</li><li> 保证调度：-n个用户登录，每个用户获得1/n的CPU处理时间，在一个有n个进程的单用户系统中，若所有进程等价，每个进程获得1/n CPU处理时间</li><li>实现：跟踪每一个进程的CPU使用时间，CPU处理使用占比最低的进程直至占比不为最低，然后CPU处理下一个最低的进程</li><li>彩票调度：为进程提供各种系统资源的彩票，一旦需要做出一项调度决策时，就随机抽取一张彩票，拥有该彩票的进程获得资源，可以给重要的进程额外的彩票。<br>即优先级为f表示拥有彩票f份额的进程大约会获得f份额的系统资源。</li><li>即使某进程只有一张彩票，经过多轮迭代，他总会获得 CPU 的使用权。所以饥饿的问题就能解决</li><li> 公平分享调度</li></ul><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><h4 id="硬实时-必须满足绝对的截止时间"><a href="#硬实时-必须满足绝对的截止时间" class="headerlink" title="硬实时-必须满足绝对的截止时间"></a>硬实时-必须满足绝对的截止时间</h4><h4 id="软实时-可以容忍"><a href="#软实时-可以容忍" class="headerlink" title="软实时-可以容忍"></a>软实时-可以容忍</h4><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存分配算法-基于位图的存储管理"><a href="#内存分配算法-基于位图的存储管理" class="headerlink" title="内存分配算法-基于位图的存储管理"></a>内存分配算法-基于位图的存储管理</h3><p>提供固定大小的内存区记录内存使用情况：在决定将一个占k个分配单元的进程调入内存，存储管理器在位图中查询有k个连续为0（0表示空闲，1表示占用）的串<br>找不到连续的分配单元返回分配失败信息或者开辟新空闲区</p><h3 id="内存分配算法-基于链表的存储管理"><a href="#内存分配算法-基于链表的存储管理" class="headerlink" title="内存分配算法-基于链表的存储管理"></a>内存分配算法-基于链表的存储管理</h3><ol><li>首次适配</li><li>下次适配（从上次分配内存的地址开始查询）</li><li>最佳适配（搜索整个链表）</li><li>最差适配(总是分配最大的可用空间)</li><li>快速适配(为常用大小的空闲区维护单独的链表)</li></ol><p><strong>查询有效空间耗时最多</strong></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>解决程序运行需要内存大于实际物理内存的问题</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p><strong>程序运行并不需要全部加载进内存中</strong><br>每个程序拥有自己的地址空间，该空间被分割成多块，每一块称为页或页面。</p><p>每一页都有连续的地址范围，这些页被映射到物理空间</p><p>当程序引用到一部分在物理内存中的地址空间时，由硬件执行映射，不在物理内存时，由操作系统将缺失部分装入物理内存</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>得到更多的线性空间<br> 虚拟地址空间被划分的单元为<strong>页面（page）</strong> 物理地址为<strong>页框（page frame）</strong> 大小相同，实际系统中为512B~1GB，<br>映射过程：<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_files/1.jpg"></p><h4 id="虚拟地址到物理地址的映射-页表"><a href="#虚拟地址到物理地址的映射-页表" class="headerlink" title="虚拟地址到物理地址的映射-页表"></a>虚拟地址到物理地址的映射-页表</h4><p>虚拟地址分为虚拟页号和偏移量</p><p>页表的目的是将虚拟页面映射为页框，虚拟页面的<strong>页号</strong>作为页表索引找到该虚拟页面的页表项</p><p>再将页表项的<strong>页框号</strong>拼接到偏移量的高位端，<strong>替换虚拟页号</strong>，形成送往内存的<strong>物理地址</strong></p><p>页表项结构：<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_files/2.jpg"></p><ol><li>保护位：三位分别表示读写执行</li><li>高速缓存禁止位：对等待I/O设备响应 确保硬件是不断从设备中读取数据而不是访问缓存中的旧数据</li><li>访问位和修改位 页面被修改必须写回磁盘，未修改直接丢弃（导入内存的是磁盘数据的副本）<h4 id="解决虚拟地址到物理地址的映射速度匹配"><a href="#解决虚拟地址到物理地址的映射速度匹配" class="headerlink" title="解决虚拟地址到物理地址的映射速度匹配"></a>解决虚拟地址到物理地址的映射速度匹配</h4></li></ol><ul><li> 将这个页表导入内存</li><li> 转换检测缓冲区-设置快表</li><li> 软件TLB管理<h4 id="处理页表过大问题"><a href="#处理页表过大问题" class="headerlink" title="处理页表过大问题"></a>处理页表过大问题</h4></li></ul><ol><li>多级页表</li><li>倒排页表-实际内存中每一个页框对应一个页表项，而不是虚拟内存对应一个页表项<br>并将页框与与之对应的虚拟页面链接形成散列表。<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4>R:访问位，M：修改位</li></ol><ul><li> 最优页面置换算法</li><li> 最近未使用页面置换算法</li><li> 先进先出页面置换算法</li><li> 第二次机会页面置换算法-避免先进先出将经常访问的页面替换出去</li><li> 修改：检查最老的页面的R位，如果是0，表示该页面最老且未访问，可以立即置换，否则将R位清0 修改装入时间并放于链表队尾</li><li> 时钟页面置换算法-弥补第二次机会页面置换算法经常在链表中移动页面的效率问题</li></ul><p> <img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_files/3.jpg"></p><ul><li> 最近最少（LRU）使用页面置换算法</li><li> 老化算法</li><li> 工作集算法-找出一个不在工作集中的页面并淘汰</li><li>一个进程当前正在使用的页面集合称为工作集</li><li>在进程运行时预先调页<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_files/5.jpg"></li><li>最坏情况，所有页面都被访问过了最好选择一个未修改的页面</li><li> 工作集时钟算法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(R==<span class="hljs-number">1</span>)&#123;<br>R=<span class="hljs-number">0</span>;<br>move next page;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>&#123;<br><span class="hljs-keyword">if</span>(T&gt;τ&amp;&amp;m==<span class="hljs-number">0</span>)change page;<span class="hljs-comment">//T为page在内存中的生存时间，τ为最长生存时间，m为修改位</span><br><span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>)&#123;<br><br>判断是否将修改页面写回磁盘(一次写操作)，写回则将m位修改为<span class="hljs-number">0</span>;<br>move next page;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>如果指针经过<strong>一圈</strong>返回起点:</li></ul><ol><li>若有至少一次写操作，则不断循环必然有一个干净页面</li><li>无写操作，随便选择一个干净页面替换并记录位置，或者选定当前页将其写回磁盘。<h4 id="补充页面大小"><a href="#补充页面大小" class="headerlink" title="补充页面大小"></a>补充页面大小</h4>进程平均为s字节，页面大小为p字节，每个页表项e个字节</li></ol><ul><li> 每个进程页数 s/p 页表空间 se/p 内部碎片平均为 p/2;</li><li> 开销=se/p+p/2;</li><li> 最优p=√2se  <h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3>在编译器编译过程中，多个表会以不可预知的方式增加或减少，地址空间分给某些表的空间已被装满，而某些表仍有的大量空间<br>编译过程可能会创建的表：</li></ul><ol><li>源程序正文</li><li>符号表，包含变量的名字和属性</li><li>包含所有整型量和符号常量的表</li><li>语法分析树，包括程序语法分析的结果</li><li>编译器内部调用使用的堆栈<br>需求：能令程序员不用管理表扩张和收缩的办法<h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4></li></ol><p><strong>将程序和数据可被划分为逻辑上独立的地址空间并有助于共享和保护</strong><br>将同一类型或属于同一逻辑实体的分为一个段，每个段构成一个独立空间，可以独立增长或减少而不影响其他段。<br>再次编译也不需要修改未改变的段</p><h3 id="段页结合"><a href="#段页结合" class="headerlink" title="段页结合"></a>段页结合</h3><p>虚拟地址(位数划分以具体系统为准)：<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_files/4.jpg"></p><p>查询算法流程：</p><ol><li>根据段号找到段描述符</li><li>检查该段是否在内存中，在就寻找，不在产生段错误，如果违反段保护要求就发出越界错误</li><li>检查所请求虚拟页面的页表项，如果不在内存就产生一个缺页中断，在就从页表项中取出该页面在内存中的起始位置</li><li>把偏移量加到页面的起始位置，得到要访问的字在内存中的地址</li><li>进行读或写操作<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_files/6.jpg"></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP和UDP的比较"><a href="#TCP和UDP的比较" class="headerlink" title="TCP和UDP的比较"></a>TCP和UDP的比较</h2><table><thead><tr><th>类型</th><th>是否面向连接</th><th>传输可靠性</th><th>传输形式</th><th>传输效率</th><th>需要资源</th><th>应用场景</th></tr></thead><tbody><tr><td>TCP</td><td>面向连接</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>要求通信数据可靠</td></tr><tr><td>UDP</td><td>无连接</td><td>不可靠</td><td>数据报文段</td><td>快</td><td>少</td><td>要求传输速度快</td></tr></tbody></table><h2 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h2><ol><li><strong>数据</strong>被分成若干TCP报文段</li><li><strong>TCP报文段</strong>首部包含32比特的序号字段和确认号字段。</li></ol><ul><li>序号字段：TCP隐式地对数据流中的每一个字节编号</li><li>确认字段：填充期望收到的下一字节号</li><li>TCP对确认的字段采取累积确认的方法</li><li>对失序的报文段进行保留而不是直接丢弃</li></ul><ol start="3"><li><strong>超时重传</strong></li></ol><ul><li>超时重传的时间间隔设置：TimeoutInterval=EstimatedRTT+4*DevRTT<ol><li>估算RTT 某一时刻测量报文段的RTT称为SampleRTT 其加权平均值为</li></ol>  EstimatedRTT=（1-α）* EstimatedRTT+α * SampleRTT （α一般为1/8)<ol start="2"><li>估算RTT的变化 DevRTT=（1-β）* DevRTT+β * |SampleRTT-EstimatedRTT|（β一般为1/4)</li></ol></li><li>定时器 使用单一的重传定时器</li><li>定时器启动条件：<ol><li>发送报文段且定时器未启动 </li><li>定时器超时重启，时间间隔翻倍 </li><li>收到ack</li></ol></li></ul><ol start="4"><li><strong>流量控制</strong> 流量控制服务是一个速度匹配服务，用于消除接收方缓存溢出的可能性</li></ol><ul><li>接收方维护一个接收缓存 大小为RcvBuffer</li><li>LastByteRead 接收端的应用进程从缓存中读取的最后一个字节的编号</li><li>LastByteRcvd 从网络中到达并由接收方接收的最后一个字节的编号</li><li>LastByteRcvd-LastByteRead≤RcvBuffer rwnd=RcvBuffer-（LastByteRcvd-LastByteRead）</li><li>发送方维护跟踪两个变量：LastByteSent 最后发送的字节编号 LastByteAcked 最后被确认的字节编号</li><li>LastByteSent-LastByteAcked≤rwnd</li><li>当rwnd=0时，发送方继续发送只有一个字节的数据，接收方返回确认报文</li></ul><p><img src="/img/network/1.jpg" alt="1"></p><ol start="5"><li><strong>拥塞控制</strong> 根据网络的拥塞情况而调整发送速度</li></ol><ul><li><p>端到端的拥塞控制：超时或3次冗余确认</p></li><li><p>网络辅助拥塞控制：路由器向发送方显示反馈网络拥塞状况</p><h3 id="如何限制发送速率，如何感知网络拥塞-如何改变发送速率"><a href="#如何限制发送速率，如何感知网络拥塞-如何改变发送速率" class="headerlink" title="如何限制发送速率，如何感知网络拥塞 如何改变发送速率"></a>如何限制发送速率，如何感知网络拥塞 如何改变发送速率</h3><ol><li><p>如何限制 LastByteSent-LastByteAcked≤min{cwnd,rwnd} (cwnd为发送方拥塞窗口大小)</p></li><li><p>如何感知 超时或3个冗余ACK</p></li><li><p>如何调整 TCP拥塞控制算法</p><p> 3.1  慢启动 指数增长</p><p> 3.2  拥塞避免 达到cwnd/2阈值 线性增长</p><p> 3.3  快恢复 </p></li></ol></li></ul><ol start="6"><li>差错恢复机制 TCP采取累积确认方式，接受方不会对正确但失序的报文段逐个确认</li></ol><h3 id="流水线的差错控制"><a href="#流水线的差错控制" class="headerlink" title="流水线的差错控制"></a>流水线的差错控制</h3><h4 id="回退N步（GBN"><a href="#回退N步（GBN" class="headerlink" title="回退N步（GBN)"></a>回退N步（GBN)</h4><h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><ol><li>累积确认</li><li>丢弃所有失序分组<h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5></li><li>超时重传所以已发送但还未确认的分组<h4 id="选择重传（SR）"><a href="#选择重传（SR）" class="headerlink" title="选择重传（SR）"></a>选择重传（SR）</h4><h5 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h5></li><li>逐个确认分组，失序分组进行缓存处理<h5 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h5></li><li>一分组一确认<h2 id="浏览器输入url地址回显页面过程"><a href="#浏览器输入url地址回显页面过程" class="headerlink" title="浏览器输入url地址回显页面过程"></a>浏览器输入url地址回显页面过程</h2><table><thead><tr><th>过程</th><th>协议</th></tr></thead><tbody><tr><td>浏览器查询域名的IP地址</td><td>DNS：获取域名对应IP</td></tr><tr><td>浏览器向web服务器发送一个http请求</td><td>TCP，IP,OPSF,ARP,HTTP</td></tr><tr><td>服务器处理请求</td><td></td></tr><tr><td>服务器返回一个html响应</td><td></td></tr><tr><td>浏览器回显html</td><td></td></tr></tbody></table></li></ol><h2 id="应用层：DNS"><a href="#应用层：DNS" class="headerlink" title="应用层：DNS"></a>应用层：DNS</h2><p>DNS提供将主机名转换为IP地址的目录服务，运行于UDP协议，端口为53号</p><h3 id="DNS服务器分类："><a href="#DNS服务器分类：" class="headerlink" title="DNS服务器分类："></a>DNS服务器分类：</h3><ul><li>根DNS服务器</li><li>顶级域DNS服务器</li><li>权威DNS服务器</li><li>本地服务器</li></ul><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><ol><li><p>递归：客户端只发一次请求，要求对方给出最终结果。</p></li><li><p>迭代：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，</p></li></ol><p>客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。<br>图示：<br><img src="/img/network/2.jpg"></p><p>3.实践中：从请求主机到本地DNS服务器是递归，其余查询是迭代的<br><img src="/img/network/3.jpg"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="数据平面-转发"><a href="#数据平面-转发" class="headerlink" title="数据平面-转发"></a>数据平面-转发</h3><p>作用：从其输入链路向其输出链路转发数据报</p><h4 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h4><h5 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h5><p>IP首部各字段：<br><img src="/img/network/4.jpg"><br>部分关键字段解释：</p><ul><li>版本号：规定IP协议版本</li><li>数据报长度：IP数据报总长度，理论长度为65535字节，实际小于等于1500字节</li><li>标识，标志，片偏移：与IP分片有关</li><li>生存时间：避免数据报在网络中永远循环，TTL减为0，数据报丢弃</li></ul><h5 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h5><ol><li>标识号：若路由器将一个数据报分为若干片时，接收端通过标识号判断哪些分片实际属于同一较大的数据报</li><li>标志：发送端将最后一个数据报的标志设为0，其余设为1<h3 id="控制平面-路由选择"><a href="#控制平面-路由选择" class="headerlink" title="控制平面-路由选择"></a>控制平面-路由选择</h3><h4 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h4></li><li>集中式路由选择算法-具有全局状态信息的算法被称作链路状态算法</li><li>Dijkstra算法</li><li>分散式路由选择算法，以迭代，分布式的方式计算最低开销路径</li><li>bellman-ford算法</li></ol><h4 id="自治系统（AS-内的路由选择协议-OSPF"><a href="#自治系统（AS-内的路由选择协议-OSPF" class="headerlink" title="自治系统（AS)内的路由选择协议-OSPF"></a>自治系统（AS)内的路由选择协议-OSPF</h4><ol><li>链路协议，洪泛链路状态信息和Dijkstra算法</li><li>优点</li><li>安全-能够鉴别OSPF路由器之间的交换</li><li>多条相同开销路径-</li><li>对单播和多播路由选择的综合支持</li><li>支持在单个AS中的层次结构-一个OSPF能够层次化地配置多个区域</li></ol><h4 id="AS之间的路由选择-BGP"><a href="#AS之间的路由选择-BGP" class="headerlink" title="AS之间的路由选择-BGP"></a>AS之间的路由选择-BGP</h4><ol><li>分布式和异步的协议</li><li>实现方式</li><li>从邻居AS获取前缀的可达性信息</li><li>确定到该前缀的”最好”路由<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="链路层寻址"><a href="#链路层寻址" class="headerlink" title="链路层寻址"></a>链路层寻址</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4></li><li>主机或路由器的适配器具有链路层地址而不是主机或路由器本身。<br>具有多个网络接口的主机或路由器将具有多个链路层地址</li><li>接受帧：</li><li>发送适配器将目的适配器的MAC地址插入该帧，并将该帧广播到局域网中，<br>局域网中各适配器接受并对比MAC地址，相同向上传递，不同则丢弃</li></ol><h4 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议-ARP"></a>地址解析协议-ARP</h4><ol><li>ARP为在同一子网内的主机和路由器接口解析IP地址</li><li>如何工作</li><li>每个主机或路由器在其内存中都有一个IP到MAC映射关系的ARP表<br>主机222.222.222.220一个可能的ARP表(TTL:该映射关系的时长，一般为20分钟)<table><thead><tr><th>IP地址</th><th>MAC地址</th><th>TTL</th></tr></thead><tbody><tr><td>222.222.222.221</td><td>88-B2-2f-54-1A-0F</td><td>13.45.00</td></tr><tr><td>222.222.222.223</td><td>5C-66-AB-90-75-B1</td><td>13.52.00</td></tr></tbody></table></li><li>主机向局域网广播目的主机的MAC地址，发送帧上插入下一跳的MAC地址</li></ol><h2 id="TCP连接-三次挥手和四次挥手"><a href="#TCP连接-三次挥手和四次挥手" class="headerlink" title="TCP连接-三次挥手和四次挥手"></a>TCP连接-三次挥手和四次挥手</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><ol><li>客户端的TCP向服务端的TCP发送一个特殊的TCP报文</li><li>不包含应用层数据</li><li>报文段首部标志位（SYN）设为1，并选择一个起始序号seq=client_isn</li><li>服务端接收到报文并发送SYNACK报文</li><li>提取TCP SYN报文段，为该TCP连接分配TCP缓存和变量</li><li>SYN设为1，确认号字段ack=client_isn 起始序号 seq=server_isn</li><li>客户端接收报文后</li><li>客户端分配TCP缓存和变量，连接建立，以后SYN标志号设为0</li></ol><h3 id="TCP关闭"><a href="#TCP关闭" class="headerlink" title="TCP关闭"></a>TCP关闭</h3><ol><li>客户端发送一个特殊的TCP报文段，FIN设为1</li><li>服务器接收后发送一个确认报文段，然后服务器发送终止报文段</li><li>客户端发送确认报文段，连接终止</li></ol><p>客户端状态：<br><img src="/img/network/5.jpg"></p><p>服务器端状态：<br><img src="/img/network/6.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>暑假总结</title>
    <link href="/2021/09/22/%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93/"/>
    <url>/2021/09/22/%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="暑假总结"><a href="#暑假总结" class="headerlink" title="暑假总结"></a>暑假总结</h1><p>大二升大三的暑假最后一天，没有疫情的话，8月15号就要开学实训的，然而南京突发疫情导致开学日期延至9月23号，总之又获得了一个漫长的暑假<br>明年暑假大概率是不回来了，或者考研或者实习，<br>中秋到现在已经放了自己四天了。想到今天是暑假最后一天，复盘一下自己的假期生活。<br>总结一下暑假的学习内容，总体还是没有达到预期的目标   <del>还是自己对自己要求太低</del></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>学习了spring+springMVC+Mybatis SSM框架 以及 springboot部分内容<br>并完成了一个ssm整合的小demo和仿天猫商城的ssm项目</p><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>跟着力扣刷题手册和代码随想录刷了200+的题，包括数组，回溯，排序，双指针，贪心，动归和二叉树</p><p>目前全部实现代码提交在github的<a href="https://github.com/nbyxs/LeetCode">LeetCode仓库</a></p><h2 id="项目整理"><a href="#项目整理" class="headerlink" title="项目整理"></a>项目整理</h2><ul><li>ssm的crud小demo</li><li>仿天猫官网的<a href="https://how2j.cn/k/tmall_ssm/tmall_ssm-1399/1399.html?p=187608">ssm项目</a></li><li>实训的<a href="https://github.com/LviatYi/AspirineManager">医药管理系统</a> （简单的页面跳转+crud，并且采用JWT进行身份验证，不过前端写的非常烂，<del>是的，就是我写的</del>，主要是学会了团队协作开发以及git的基本使用)</li></ul><h2 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h2><ol><li>《计算机网络自顶向下》 看到第四章 网络层 啃不动了，</li><li>《算法》 第四版 结合刷题选择性的看，看了排序，二叉树等章节</li><li>《二战历史年记》才看了前三章 23333</li></ol><h2 id="博客学习"><a href="#博客学习" class="headerlink" title="博客学习"></a>博客学习</h2><ul><li><a href="https://snailclimb.gitee.io/">JavaGuide的博客及面试整理</a><ul><li><pre><code>熟悉了java基础+集合+多线程</code></pre></li><li><pre><code>了解了JVM</code></pre></li><li><pre><code>复习了操作系统+计算机网络</code></pre></li><li><pre><code>了解了数据库事务和索引等内容</code></pre></li><li><pre><code>巩固spring框架的知识</code></pre></li></ul></li></ul><h2 id="下阶段的计划："><a href="#下阶段的计划：" class="headerlink" title="下阶段的计划："></a>下阶段的计划：</h2><ol><li>完成springboot以及redis学习，并完成在线教育的项目</li><li>复习刷过的题目，继续看面经</li><li>尝试找实习，寒假之前找不到就准备考研了</li><li>努力养成看书的习惯，大部头确实难啃，也许人与人的区分度就在这上面了。道理懂得都懂，实践就是另外一回事了。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>感谢我爸妈在我整个暑假基本宅在家里也没什么怨言 <del>虽然我也有做饭什么的，嘻嘻</del> 以后也许会离家的时间会越来越长，不太会有如此长的时间陪伴父母。</p><p>自认为并不是一个好学生，可能是周围环境没有压力，宛如温水煮青蛙，学习的动力只能靠自己自觉或ddl的临近。这样噩噩浑浑了两年，感觉自己学了点，但又不知道学了什么，更不知道学了怎么用。</p><p>这不是一个好现象，而且我认为这种现象在同龄人中不在少数。临近毕业才发现自己玩了四年，步入社会而没有准备好，随着潮流考公考研，想得很多却做得很少</p><p>一句话：”我没有准备好。”</p><p>当重拾起来的时候，发现面对庞大的知识体系无从下手，力不从心，最终无功而返，功败垂成，折戟沉沙或功败垂成，前功尽弃。却不曾想自己是在偿还四年欠下的债。</p><p>间接性踌躇满志，持续性混吃等死是人的通病。</p><p>知识学的越来越多，越感觉自己的渺小，越发战战兢兢，如履薄冰，如临深渊。</p><p>学习是终生的事情，懒惰是人的天性，也许换句话说 人的一生就是和懒惰抗争的一生？</p><p>认清现实，抛弃幻想，努力奋斗。</p><p>暂时扯这么多，以后想到的再补充吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring</title>
    <link href="/2021/09/18/spring/"/>
    <url>/2021/09/18/spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是 Spring仍然可以和其他的框架无缝整合。</p><h2 id="spring特征：轻量，控制反转，面向切面，容器，框架"><a href="#spring特征：轻量，控制反转，面向切面，容器，框架" class="headerlink" title="spring特征：轻量，控制反转，面向切面，容器，框架"></a>spring特征：轻量，控制反转，面向切面，容器，框架</h2><ul><li>控制反转（IOC）：控制反转原则（或DI，依赖注入）<br>  在此过程中，对象仅通过构造函数参数、工厂方法参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖项(即它们使用的其他对象)；<br>  从根本上说，这个过程是bean本身通过直接构造类或Service Locator模式等机制来控制依赖项的实例化或位置的相反过程(因此得名“控制反转”)。</li></ul><h2 id="spring核心组件："><a href="#spring核心组件：" class="headerlink" title="spring核心组件："></a>spring核心组件：</h2><p><img src="spring_files/1.jpg"></p><h2 id="spring常用模块："><a href="#spring常用模块：" class="headerlink" title="spring常用模块："></a>spring常用模块：</h2><p><img src="spring_files/2.jpg"></p><h2 id="spirng-IOC原理"><a href="#spirng-IOC原理" class="headerlink" title="spirng IOC原理"></a>spirng IOC原理</h2><p>spring IoC实现原理是工厂模式+反射机制</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务与索引整理</title>
    <link href="/2021/09/17/sql/"/>
    <url>/2021/09/17/sql/</url>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><p><strong>事务</strong>（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，<br>即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。<br>如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</p><h3 id="ACID事务特性："><a href="#ACID事务特性：" class="headerlink" title="ACID事务特性："></a>ACID事务特性：</h3><p>1、原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。<br>2、一致性或可串性：事务的执行使得数据库从一种正确状态转换成另一种正确状态<br>3、隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务<br>4、持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>√</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）</p><h3 id="并发事务可能带来的问题"><a href="#并发事务可能带来的问题" class="headerlink" title="并发事务可能带来的问题"></a>并发事务可能带来的问题</h3><p>1.<strong>脏读</strong>：事务对数据进行修改但未提交至数据库，另一个事务访问同一数据称为脏数据，依据该数据进行的操作可能是不正确的<br>2.<strong>丢失修改</strong>：两个事务同时对同一数据进行修改操作，第二个事务的修改结果可能会覆盖第一个事务的结果，造成修改数据错误<br>3.<strong>不可重复读</strong>：在一个事务多次访问同一数据的期间，另一个并发事务访问该数据并进行修改，可能导致该事务多次访问的数据不同<br>4.<strong>幻读</strong>：在一个事务多次查询特定记录期间，另一个并发事务插入了几条记录，可能导致该事务多次查询结果不相同</p><h3 id="大表优化方式："><a href="#大表优化方式：" class="headerlink" title="大表优化方式："></a>大表优化方式：</h3><ul><li>1.字段：<ul><li>1.1尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</li><li>1.2VARCHAR的长度只分配真正需要的空间</li><li>1.3使用枚举或整数代替字符串类型</li><li>1.4尽量使用TIMESTAMP而非DATETIME，</li><li>1.5单表不要有太多字段，建议在20以内</li><li>1.6避免使用NULL字段，很难查询优化且占用额外索引空间</li><li>1.7用整型来存IP</li></ul></li></ul><p>2.限定数据范围<br>3.读写分离：主库负责写，从库负责读<br>4.垂直分区：将数据表列拆分<br>5.水平分区：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><h3 id="简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别"><a href="#简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别" class="headerlink" title="简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别"></a>简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别</h3><ul><li>MyISAM： <ul><li>1.不支持事务，但是每次查询都是原子的；</li><li>2.支持表级锁，即每次操作是对整个表加锁；</li><li>3.存储表的总行数； </li><li>4.一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；</li><li>5.采用非聚集索引，索引文件的数据域存储指向数据文件的指针。</li><li>6.辅索引与主索引基本一致，但是辅索引不用保证唯一性。 </li></ul></li><li>InnoDb：<ul><li>1.支持 ACID 的事务，支持事务的四种隔离级别；</li><li>2.支持行级锁及外键约束：因此可以支持写并发；</li></ul></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h3 id="索引的目的是什么？"><a href="#索引的目的是什么？" class="headerlink" title="索引的目的是什么？"></a>索引的目的是什么？</h3><p>1.快速访问数据表中的特定信息，提高检索速度<br>2.创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>3.加速表和表之间的连接<br>4.使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</p><h3 id="索引对数据库系统的负面影响是什么？"><a href="#索引对数据库系统的负面影响是什么？" class="headerlink" title="索引对数据库系统的负面影响是什么？"></a>索引对数据库系统的负面影响是什么？</h3><p>负面影响：<br><strong>创建</strong>索引和维护索引需要耗费时间，这个时间随着<strong>数据量</strong>的增加而增加；<br>索引需要占用<strong>物理空间</strong>，不光是表需要占用数据空间，每个索引也需要占用物理空间；<br>当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p><h3 id="为数据表建立索引的原则有哪些？"><a href="#为数据表建立索引的原则有哪些？" class="headerlink" title="为数据表建立索引的原则有哪些？"></a>为数据表建立索引的原则有哪些？</h3><p>在最频繁使用的、用以缩小查询范围的字段上建立索引。<br>在频繁使用的、需要排序的字段上建立索引</p><h3 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h3><p>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。<br>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="什么是乐观锁"><a href="#什么是乐观锁" class="headerlink" title="什么是乐观锁"></a>什么是乐观锁</h3><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；<br>悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，</p><h4 id="乐观锁的实现方式："><a href="#乐观锁的实现方式：" class="headerlink" title="乐观锁的实现方式："></a>乐观锁的实现方式：</h4><p><strong>版本号</strong>：给数据增加一个版本标识，在数据库上就是表中增加一个version字段，<br>每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version，如果还是开始读取的version就可以更新了，<br>如果现在的version比老的version大，说明有其他事务更新了该数据，并增加了版本号，<br>这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理<br><strong>时间戳</strong>（timestamp）：和版本号基本一样，只是通过时间戳来判断而已，<br>注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。<br><strong>待更新字段</strong>：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息</p><h3 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁"></a>什么是悲观锁</h3><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，</p><h4 id="悲观锁按性质分："><a href="#悲观锁按性质分：" class="headerlink" title="悲观锁按性质分："></a>悲观锁按性质分：</h4><p>排他锁（x锁）：事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以<strong>同时读</strong>，但<strong>不能有写操作</strong>，直到A释放S锁。<br>共享锁（s锁）：事务A对对象T加X锁以后，其他事务<strong>不能对T加任何锁</strong>，只有事务A可以读写对象T直到A释放X锁。<br>更新锁（u锁）：用来预定要对此对象施加X锁，它<strong>允许其他事务读</strong>，但<strong>不允许再施加U锁或X锁</strong>；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的</p><h3 id="什么是行级锁"><a href="#什么是行级锁" class="headerlink" title="什么是行级锁"></a>什么是行级锁</h3><p>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时， Oracle 会自动应用行级锁：</p><ol><li>INSERT、 UPDATE、 DELETE、 SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</li><li>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</li><li>使用 COMMIT 或 ROLLBACK 语句释放锁。</li></ol><h3 id="什么是表级锁"><a href="#什么是表级锁" class="headerlink" title="什么是表级锁"></a>什么是表级锁</h3><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。<br>最常使用的MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 </p><h3 id="什么是页级锁"><a href="#什么是页级锁" class="headerlink" title="什么是页级锁"></a>什么是页级锁</h3><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。<strong>表级锁速度快，但冲突多，行级冲突少，但速度慢。</strong><br>所以取了折衷的页级，一次锁定相邻的一组记录。</p><h2 id="数据库三大范式："><a href="#数据库三大范式：" class="headerlink" title="数据库三大范式："></a>数据库三大范式：</h2><p>第一范式：<strong>属性</strong>不可分<br>第二范式：非主属性不存在对主键的<strong>部分依赖</strong><br>第三范式：非主属性不存在对主键的<strong>传递依赖</strong></p><h2 id="数据库索引："><a href="#数据库索引：" class="headerlink" title="数据库索引："></a>数据库索引：</h2><p>主键的作用：</p><p>1.可以保证实体的完整性；<br>2.能够加快数据库的操作速度；<br>3.确定数据唯一性<br>…</p><h3 id="为什么主键能加快数据库的操作速度？–-gt-为什么索引能加快数据库操作速度？"><a href="#为什么主键能加快数据库的操作速度？–-gt-为什么索引能加快数据库操作速度？" class="headerlink" title="为什么主键能加快数据库的操作速度？–&gt;为什么索引能加快数据库操作速度？"></a>为什么主键能加快数据库的操作速度？–&gt;为什么索引能加快数据库操作速度？</h3><p>在没有添加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列<br>如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，<br>也就是上面说的「B Tree/B+ Tree」结构，换句话说，就是整个表就变成了一个索引。<br><strong>主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。</strong></p><p>非聚簇索引与树结构无关，与树存放的内容有关；<br>1.data域存放的是数据记录的地址，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。<br>2.data域保存了完整的数据记录，这个索引的key是数据表的主键，这被称为“聚簇索引（或聚集索引）”。</p><p><img src="/img/1.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/16/hello-world/"/>
    <url>/2021/09/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

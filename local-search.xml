<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>jvm</title>
    <link href="/2021/10/08/jvm/"/>
    <url>/2021/10/08/jvm/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域分布"><a href="#Java内存区域分布" class="headerlink" title="Java内存区域分布"></a>Java内存区域分布</h1><p>java内存区域分布图：<br><img src="/img/jvm_files/1.jpg"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序控制流的指示器<br>实现线程切换后的恢复和正确执行</p><h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>描述Java方法执行的线程内存模型<br>每个方法执行虚拟机栈创建一个栈帧存放局部变量表，操作数栈等信息<br>局部变量表存放的是 基本数据类型，对象引用，返回值类型订单</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>使用本地方法服务</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>存放几乎一切对戏实例和数组</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>存储已被虚拟机加载的类型信息，常量，静态变量</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>方法区的一部分，存放编译期生成的各种字面量和符号引用</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显<br>著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。</p><h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>创建流程图：</p><p><img src="/img/jvm_files/2.jpg"></p><h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><h3 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h3><p>java堆内存绝对规整（中间由指针作为分界点指示器）：<br><img src="/img/jvm_files/3.jpg"></p><p><strong>将指针向空闲空间方向挪动与对象大小相同的距离</strong></p><h3 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h3><p>java堆内存相互交错：<br><img src="/img/jvm_files/4.jpg"></p><p>虚拟机需维护一个列表，记录可用内存块<br>分配时找到一块足够大的空间划分给对象实例，并更新记录</p><h2 id="对象头初始化"><a href="#对象头初始化" class="headerlink" title="对象头初始化"></a>对象头初始化</h2><p>对象头信息类型:<strong>对象自身运行数据和类型指针</strong></p><h3 id="对象自身运行数据"><a href="#对象自身运行数据" class="headerlink" title="对象自身运行数据"></a>对象自身运行数据</h3><table><thead><tr><th>存储内容</th><th>标志位</th><th>状态</th></tr></thead><tbody><tr><td>对象哈希码，对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>重量级锁定</td></tr><tr><td>空</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID，偏向时间戳，对象分代年龄</td><td>01</td><td>可偏向</td></tr></tbody></table><h3 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h3><p>对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象对应的类</p><h2 id="对象实例化"><a href="#对象实例化" class="headerlink" title="对象实例化"></a>对象实例化</h2><p>按规定顺序记录字段</p><h1 id="垃圾回收器和内存分配策略"><a href="#垃圾回收器和内存分配策略" class="headerlink" title="垃圾回收器和内存分配策略"></a>垃圾回收器和内存分配策略</h1><h2 id="如何判断对象可回收"><a href="#如何判断对象可回收" class="headerlink" title="如何判断对象可回收"></a>如何判断对象可回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>很难解决对象相互循环引用的情况</p><h3 id="可达性算法"><a href="#可达性算法" class="headerlink" title="可达性算法"></a>可达性算法</h3><p>基本思路：通过一系列称为“GC Roots”的根对象作为起始节点集，根据引用关系向下搜索，<br>搜索过程所走过的路径称为”引用链”</p><p>如果某个对象对于GC Roots不可达，说明该对象可会回收。<br>GC Roots对象种类：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中本地方法引用的对象</li><li>虚拟机中内部引用</li><li>所有被同步锁持有的对象</li><li>….<br><img src="/img/jvm_files/5.jpg"></li></ul><h2 id="引用类型的扩充"><a href="#引用类型的扩充" class="headerlink" title="引用类型的扩充"></a>引用类型的扩充</h2><p>引用扩充之前对象状态只有”引用”,”未引用”两种，对于一些如暂存在缓存中的对象无法精确的描述</p><p>这一类对象的特点：当内存空间还足够时留在内存，不够时抛弃。</p><p>java对引用进行扩充为：强引用，软引用，弱引用，虚引用，，，，</p><p>引用强度依次降低。</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机<br>宁愿<strong>抛出OutOfMemoryError错误，使程序异常终止，</strong>也不会靠随意回收具有强引用的对象来解决内存不足问题</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>如果一个对象只具有软引用，那就类似于可有可无的生活用品。</p><p>如果内存空间足够，垃圾回收器就不会回收它，如果<strong>内存空间不够了，就会回收这些对象的内存。</strong>如果回收还是内存不足，才会抛出内存溢出异常。</p><p>只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>强度弱于软引用，与之关联的对象只能生存到下一次垃圾收集。无论内存是否充足，都会被回收<strong>只与弱引用相关联</strong>的对象</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>目的：在对象回收时收到一个系统通知</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p><strong>理论基础：</strong> </p><ul><li>弱分代假说：绝大多数对象都是朝生夕灭</li><li>强分代假说：经历垃圾收集过程越多的对象就越难消亡</li></ul><p><strong>垃圾收集器设计原则</strong>：收集器应将java堆划分为不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储。</p><p>将java堆区分为新生代和老生代：</p><p>新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</p><p>老生代的对象存活率是较高的，且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>它可以将内存分为相同的两块，每次使用其中的一块。<br>当这一块的内存使用完后，就将还存活的对象复制到另一块去，<br>然后再把使用的空间再次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，但是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="/img/jvm_files/6.jpg"></p><h1 id="线程安全和锁优化"><a href="#线程安全和锁优化" class="headerlink" title="线程安全和锁优化"></a>线程安全和锁优化</h1><h2 id="线程安全分类"><a href="#线程安全分类" class="headerlink" title="线程安全分类"></a>线程安全分类</h2><ol><li>不可变</li><li>绝对线程安全</li><li>相对线程安全</li><li>线程兼容</li><li>线程对立<h2 id="线程安全实现方法"><a href="#线程安全实现方法" class="headerlink" title="线程安全实现方法"></a>线程安全实现方法</h2></li><li>互斥同步</li><li>非阻塞同步<br>互斥同步属于悲观并发策略<br>无论共享的数据是否会出现竞争都会加锁，频繁的用户态核心态的切换，锁计数器的检查，线程的阻塞和唤醒</li></ol><p>非阻塞同步基于冲突检测的乐观并发策略————尝试获取共享数据，成功则占用，不成功再进行其他补救措施</p><p>实现指令有</p><ul><li>测试并设置</li><li>获取并增加</li><li>交换</li><li>比较并交换（CAS）</li><li>加载链接/条件存储<h3 id="CAS详解"><a href="#CAS详解" class="headerlink" title="CAS详解"></a>CAS详解</h3>CAS指令操作数：内存位置(V),旧的预期值(A),新的预期值(B)</li></ul><p>指令执行iff V符合A时，处理器才会用B更新V的值。</p><p>漏洞：</p><ol><li>ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化 ，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。<br>在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。</li><li>循环时间长开销大</li><li>只能保证一个共享变量的原子操作。</li></ol><h2 id="引入锁优化原因"><a href="#引入锁优化原因" class="headerlink" title="引入锁优化原因"></a>引入锁优化原因</h2><p><strong>线程之间更高效地共享数据及解决竞争问题，提高程序执行效率</strong></p><h3 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h3><p>线程的挂起和恢复消耗(即用户态与核心态之间的切换)对性能影响最大，共享数据的锁定状态只会持续很短一段时间，为之付出的资源消耗并不值得。</p><p>自适应自旋时间由前一次在同一个锁上自旋时间以及锁拥有者的状态决定的</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>虚拟机探测到一串零碎的操作都对同一个对象加锁，会将加锁同步的范围扩大到整个操作序列的外部</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>设计初衷：在没有多线程竞争前提下，减少传统重量级锁使用操作系统互斥量产生的性能消耗</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>消除数据在无竞争情况下的同步原语，进一步提高程序运行性能</p><p>该锁会偏向第一个获得它的线程，在之后的执行中没有线程的竞争则持有该锁的线程不需同步</p><p>锁关系的转化：<br><img src="/img/jvm_files/9.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java基础整理</title>
    <link href="/2021/09/30/java/"/>
    <url>/2021/09/30/java/</url>
    
    <content type="html"><![CDATA[<h1 id="封装，继承和多态"><a href="#封装，继承和多态" class="headerlink" title="封装，继承和多态"></a>封装，继承和多态</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装把一个对象的属性私有化，同时提供外界访问的对应属性的方法</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>基于已有类创建新类。新类就是复用该类的方法，可以增加新方法和属性适应新情况</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>相同的消息(参数列表或方法调用)给予不同的对象会引发不同的动作。</p><h1 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h1><p>目的：将基本类型转为对象。所有基本类型都有对应的类-包装器类<br>如定义一个整型数组列表，尖括号中的类型参数不允许是基本数据类型。需要使用包装器类。<br>包装器类为final，不能派生。</p><h2 id="自动装箱和装箱"><a href="#自动装箱和装箱" class="headerlink" title="自动装箱和装箱"></a>自动装箱和装箱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">var</span> list=<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><span class="hljs-comment">//装箱</span><br>list.add(Integer.valueOf(<span class="hljs-number">3</span>));<br><span class="hljs-comment">//拆箱，将一个Integer对象赋给int 自动拆箱</span><br><span class="hljs-keyword">int</span> n=list.get(<span class="hljs-number">1</span>).intValue();<br><br></code></pre></td></tr></table></figure><h1 id="静态字段和静态方法"><a href="#静态字段和静态方法" class="headerlink" title="静态字段和静态方法"></a>静态字段和静态方法</h1><p>将一个变量由static修饰符修饰，则类中只有一个对应字段，非静态变量，每个对象都有一个对应副本</p><h1 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals"></a>== 与 equals</h1><p>==: 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据<br>类型==比较的是值，引用数据类型==比较的是内存地址)。<br>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况 1：类没有覆盖 equals()方法。则通过 equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。<h2 id="如何重写equal-方法"><a href="#如何重写equal-方法" class="headerlink" title="如何重写equal()方法"></a>如何重写equal()方法</h2></li><li>自反性：对于任何非空引用x x.equals(x)返回true</li><li>对称性：对于任何非空引用x，y x.equals(y)返回true</li><li>传递性: 对于任何非空引用 x,y,z if x.equals(y) 返回true &amp;&amp; y.equals(z)返回true 则x.equal(z)返回true</li><li>一致性：对于任何非空引用x，y 反复调用x.equals(y)返回结果相同</li><li>对于任何非空引用x，x.equals(null) 返回false<h1 id="equals-方法和hashCode-方法"><a href="#equals-方法和hashCode-方法" class="headerlink" title="equals 方法和hashCode()方法"></a>equals 方法和hashCode()方法</h1><h1 id="final"><a href="#final" class="headerlink" title="final"></a>final</h1></li><li>变量：final修饰，基本数据类型初始化后值不变，引用数据类型不能指向另一个对象</li><li>类：final修饰的类不能被继承</li><li>方法：final修饰的方法不能被重写<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1>异常类型结构：<br><img src="/img/java/2.jpg"><h2 id="RuntimeException："><a href="#RuntimeException：" class="headerlink" title="RuntimeException："></a>RuntimeException：</h2></li><li>强制类型转换错误</li><li>数组访问越界</li><li>空指针异常<h2 id="IOException"><a href="#IOException" class="headerlink" title="IOException"></a>IOException</h2></li><li>试图查阅文件末尾读取文件</li><li>试图打开一个不存在的文件</li><li>试图根据规定的字符串查找Class对象，而该字符串表示的类不存在<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2></li><li>内存不足</li><li>堆栈溢出</li><li>VirtualMachineError虚拟机错误。用于指示虚拟机被破坏或者继续执行操作所需的资源不足的情况。</li></ul><h1 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO,NIO,AIO"></a>BIO,NIO,AIO</h1><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步请求，A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。</p><p>异步请求，A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。</p><p>所以说，同步和异步最大的区别就是被调用方的<strong>执行方式</strong>和<strong>返回时机</strong>。</p><p>同步指的是被调用方做完事情之后再返回。</p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞请求，A调用B，A一直等着B的返回，别的事情什么也不干。</p><p>非阻塞请求，A调用B，A不用一直等着B的返回，先去忙别的事情了。</p><p>所以说，阻塞非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。</p><p>阻塞指的是调用方一直等待别的事情什么都不做。</p><p>非阻塞指的是调用方先去忙别的事情。</p><p>异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。</p><p>BIO （Blocking I/O）：同步阻塞I/O模式。</p><p>NIO （New I/O）：同步非阻塞模式。</p><p>AIO （Asynchronous I/O）：异步非阻塞I/O模型。<br>阻塞、非阻塞说的是调用者，同步、异步说的是被调用者。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p><p>AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p><h1 id="数据结构部分"><a href="#数据结构部分" class="headerlink" title="数据结构部分"></a>数据结构部分</h1><h2 id="ArrayList扩容机制"><a href="#ArrayList扩容机制" class="headerlink" title="ArrayList扩容机制"></a>ArrayList扩容机制</h2><ul><li>成员变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个空数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">//也是一个空数组，跟上边的空数组不同之处在于，这个是在默认构造器时返回的，扩容时需要用到这个作判断，后面会讲到</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><span class="hljs-comment">//存放数组中的元素，注意此变量是transient修饰的，不参与序列化</span><br><span class="hljs-comment">//有参构造使用</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-comment">//数组的长度，此参数是数组中实际的参数，区别于elementData.length，后边会说到</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br></code></pre></td></tr></table></figure></li><li>无参构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>有参构造<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br><span class="hljs-comment">//注意根据参数长度声明不同的数组</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>特定元素的集合构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    elementData = c.toArray();<br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] </span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// replace with empty array.</span><br>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3>扩容从add方法开始：<br>ensureCapacityInternal方法会调用calculateCapacity()方法<br>此方法会判断当前数组是否为DEFAULTCAPACITY_EMPTY_ELEMENTDATA,如果是则返回长度的最大值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//队尾插入元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-comment">//指定位置插入元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    rangeCheckForAdd(index);<br><br>   ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));<br>&#125;<br><span class="hljs-comment">//此方法会返回DEFAULT_CAPACITY（值为10）和minCapacity的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minCapacity;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    modCount++;<br>    <span class="hljs-comment">// overflow-conscious code 调用扩容方法</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="HashMap-HashTable-ConcurrentHashMap"><a href="#HashMap-HashTable-ConcurrentHashMap" class="headerlink" title="HashMap HashTable ConcurrentHashMap"></a>HashMap HashTable ConcurrentHashMap</h2></li></ul><table><thead><tr><th>数据结构</th><th>底层实现</th><th>初始size</th><th>每次扩容大小</th><th>是否线程安全</th><th>键值对是否为null</th><th>负载因子</th></tr></thead><tbody><tr><td>HashMap</td><td>jdk1.7:数组+链表 1.8之后数组+链表/红黑树</td><td>16</td><td>size*2</td><td>否</td><td>允许一个null key 多个null val</td><td>0.75</td></tr><tr><td>HashTable</td><td>数组+链表</td><td>11</td><td>size*2+1</td><td>是</td><td>不允许</td><td>0.75</td></tr><tr><td>ConcurrentHashMap</td><td>HashMap</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ul><li>底层采用分段的数组+链表实现，线程安全</li><li>通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)</li><li>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术</li><li>有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁</li><li>扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容</li></ul><h4 id="为什么说HashMap是线程不安全的？"><a href="#为什么说HashMap是线程不安全的？" class="headerlink" title="为什么说HashMap是线程不安全的？"></a>为什么说HashMap是线程不安全的？</h4><p>在接近临界点时，若此时两个或者多个线程进行put操作，都会进行resize（扩容）和reHash（为key重新计算所在位置），而reHash在并发的情况下可能会形成链表环。<br>总结来说就是在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%。</p><h4 id="HashMap扩容"><a href="#HashMap扩容" class="headerlink" title="HashMap扩容"></a>HashMap扩容</h4><p>HashMap根据链地址法（拉链法）来解决冲突，<br>在jdk1.8中，如果链表长度大于8且节点数组长度大于64的时候，<br>就把链表下所有的节点转为双向链表再转化为红黑树。</p><h5 id="为什么HashMap为什么要树化？"><a href="#为什么HashMap为什么要树化？" class="headerlink" title="为什么HashMap为什么要树化？"></a>为什么HashMap为什么要树化？</h5><p>在jdk1.7时，HashMap是由数组+链表实现的。<br>如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，<br>我们知道链表查询是线性的，会严重影响存取的性能。<br>恶意代码就可以利用这些数据与服务器端交互时构造哈希冲突，导致服务器端CPU大量占用</p><h5 id="为什么要将链表中转红黑树的阈值设为8？"><a href="#为什么要将链表中转红黑树的阈值设为8？" class="headerlink" title="为什么要将链表中转红黑树的阈值设为8？"></a>为什么要将链表中转红黑树的阈值设为8？</h5><p>当链表长度大于或等于阈值（默认为 8）的时候，如果同时还满足容量大于或等于 MIN_TREEIFY_CAPACITY（默认为 64）的要求，就会把链表转换为红黑树。<br>同样，后续如果由于删除或者其他原因调整了大小，当红黑树的节点小于或等于 6 个以后，又会恢复为链表形态。<br>当链表过长时，为了提高性能，需要将链表转化为红黑树<br>链表长度符合泊松分布，各个长度的命中概率依次递减，当长度为 8 的时候，是最理想的值。</p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="引入多线程的原因"><a href="#引入多线程的原因" class="headerlink" title="引入多线程的原因"></a>引入多线程的原因</h2><ul><li>提高<strong>资源利用率</strong></li><li>提高拥有资源的<strong>公平性</strong></li><li>执行多任务编写多个程序，<strong>提高便利性</strong><h2 id="多线程的优势"><a href="#多线程的优势" class="headerlink" title="多线程的优势"></a>多线程的优势</h2></li><li>降低程序开发和维护成本</li><li>提高复杂应用程序的性能</li><li>更好地模拟人类工作方式和交互方式</li><li>降低代码复杂度，使代码更易编写，阅读和维护</li><li>…..<h1 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h1><h2 id="什么是线程安全性"><a href="#什么是线程安全性" class="headerlink" title="什么是线程安全性"></a>什么是线程安全性</h2></li><li>线程安全性的核心–正确性</li><li>正确性：某个类的行为和其规范的完全一致。</li><li>线程安全性：当多个线程访问某个类时，这个类始终能表现出正确的行为<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2>不可分割的操作<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3>当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件<br>最常见的竞态条件：先检查后执行操作</li></ul><p>在简单性和并发性之间的平衡：<br><img src="/img/java/1.jpg"></p><h1 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h1><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p>将变量声明为volatile类型后，编译器和运行都会注意该变量是共享的，因此不会将其余其他操作重排序<br>也不会被缓存在寄存器或者对其他处理器不可见的地方。<br>通常用于某个操作的完成，发生中断或状态的标志<br>当且仅当满足以下所有条件时，才应该使用volatile变量:</p><ul><li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li><li>该变量不会与其他状态变量一起纳人不变性条件中。</li><li>在访问变量时不需要加锁。<h2 id="发布与逸出"><a href="#发布与逸出" class="headerlink" title="发布与逸出"></a>发布与逸出</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3>发布：使对象能够在当前作用域之外的代码中使用<br>逸出：当某个不应该发布的对象被发布，例如在对象构造完成之前就发布该对象</li></ul><p>发布最简单的方法：将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> set&lt;Secret&gt; knownsecrets ;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">( )</span></span>&#123;<br>knownsecrets = <span class="hljs-keyword">new</span> Hashset&lt;secret&gt; () ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><ul><li>对象创建后状态不能修改</li><li>对象所有域都是final类型</li><li>对象是正确创建的（在创建期间，this引用没有逸出）</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/09/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/09/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统总结"><a href="#操作系统总结" class="headerlink" title="操作系统总结"></a>操作系统总结</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>概念：当一个进程在用户态执行一个用户程序时，需要一个系统服务，则必须执行一个陷阱或系统调用指令，将控制转移到操作系统。<br>操作系统通过参数查找<strong>需要系统调用</strong>的进程，为其执行系统调用，并把控制返回在系统调用后后面跟随着的指令。</p><p>个人理解：学渣（用户态）在做作业（运行多个进程）时碰到不会做的题目<strong>寻求学霸帮忙</strong>（寻求帮助——系统调用），学霸将作业接手（该进程陷入内核），此时学渣或等待其完成该题（下一道题可能需要这一题的结果——下一条指令需要这一条指令的执行结果） 或继续做下一道题（执行无关指令）</p><h3 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h3><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>pid=fork()</td><td>创建与父进程相同的子进程</td></tr><tr><td>pid=watipid(pid,&amp;statloc,options)</td><td>等待一个进程终止</td></tr><tr><td>s=execve(name,argv,environp)</td><td>替换一个进程核心映像</td></tr><tr><td>exit(status)</td><td>终止进程执行并返回结果</td></tr></tbody></table><h3 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h3><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>fd=open(file,how,…)</td><td>打开文件读写</td></tr><tr><td>s=close(fd)</td><td>关闭文件</td></tr><tr><td>n=read(fd,buffer,nbytes)</td><td>把数据从一个文件读到缓冲区</td></tr><tr><td>n=write(fd,buffer,nbytes)</td><td>把数据从缓冲区写回文件</td></tr><tr><td>position=Iseek(fd,offset,whence)</td><td>移动文件指针</td></tr><tr><td>s=stat(name,&amp;buf)</td><td>获取文件状态信息</td></tr></tbody></table><h3 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h3><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>s=mkmdir(name,mode)</td><td>创建一个新目录</td></tr><tr><td>s=rmdir(name,mode)</td><td>删除一个空目录</td></tr><tr><td>s=link(name1,name2)</td><td>创建一个新目录项name2并指向目录name1</td></tr><tr><td>s=unlink(name)</td><td>删除一个目录项</td></tr><tr><td>s=mount(special,name,flag)</td><td>安装一个文件系统</td></tr><tr><td>s=umount(special)</td><td>删除一个文件系统</td></tr></tbody></table><h3 id="各种系统调用"><a href="#各种系统调用" class="headerlink" title="各种系统调用"></a>各种系统调用</h3><table><thead><tr><th>调用</th><th>说明</th></tr></thead><tbody><tr><td>s=chdir(dirname)</td><td>改变目录工程</td></tr><tr><td>s=chmod(name,mode)</td><td>修改一个文件的保护位</td></tr><tr><td>s=kill(pid,signal)</td><td>发送信号给一个进程</td></tr><tr><td>seconds=time(&amp;seconds)</td><td>自1970年1月1日流逝的时间</td></tr></tbody></table><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ol><li>概念：一个进程就是一个程序实例，包括程序计数器，寄存器和变量当前值<br>有程序，输入，输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法来切换进程<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4></li></ol><ul><li> 系统初始化</li><li> 正在运行的程序执行创建进程的系统调用</li><li> 用户请求创建进程</li><li> 批处理作业初始化</li></ul><h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><ul><li> 正常退出</li><li> 出错退出</li><li> 严重错误</li><li> 被其他进程杀死<h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4></li><li> UNIX 进程和它所有的子进程共同组成一个进程组</li><li> Windows 所有进程地位相同，父进程拥有令牌（句柄）控制子进程 <h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><h4 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h4>操作系统维护一张进程表，每个进程占有一个进程控制块（进程表项) </li></ul><p>PCB包含信息：</p><ul><li>程序计数器</li><li>堆栈指针</li><li>内存分配情况</li><li>所打开文件状态</li><li>账号和调度信息</li></ul><h5 id="中断过程"><a href="#中断过程" class="headerlink" title="中断过程"></a>中断过程</h5><ol><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装入新的程序计数器</li><li>汇编语言保存寄存器值</li><li>汇编语言设置新的堆栈</li><li>C中断服务历程运行（典型地读和缓冲输入）</li><li>调度程序决定运行进程</li><li>C过程返回汇编代码</li><li>汇编语言开始运行新进程<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3>进程模型基于两个独立的概念：<strong>资源分组和运行</strong></li></ol><p>进程将资源集中起来，线程是在cpu被调度执行的实体</p><ol><li>理由</li></ol><ul><li> 线程比进程更轻量级</li><li> 平衡CPU处理和I/O处理</li><li> 将多个应用程序分解成准并行运行的多个顺序线程，程序设计模型会更简单<h4 id="用户态下的线程切换"><a href="#用户态下的线程切换" class="headerlink" title="用户态下的线程切换"></a>用户态下的线程切换</h4>进程维护一张线程表，发送阻塞时，检查表中可运行的就绪线程，并把新线程的保存值重新装入机器的寄存器中</li></ul><p>线程的切换可以在几个指令内完成，不需要陷入内核，不需要上下文切换，也不需要对内存高速缓存刷新</p><h4 id="核心态的线程切换"><a href="#核心态的线程切换" class="headerlink" title="核心态的线程切换"></a>核心态的线程切换</h4><p>内核的线程表保存每一个线程的寄存器，状态和其他信息，同时维护进程表</p><p>线程阻塞时，由内核决定运行同一进程中的另一个线程</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><strong>如何确保多个进程在关键活动中不会出现交叉？进程间信息是如何传递的？如何正确按序执行进程？</strong></p><h3 id="在共享内存实现互斥访问"><a href="#在共享内存实现互斥访问" class="headerlink" title="在共享内存实现互斥访问"></a>在共享内存实现互斥访问</h3><ol><li>屏蔽中断 每个进程在刚刚进入临界区屏蔽中断，离开打开中断</li><li>锁变量 锁变量0,1之间转换</li><li>严格轮转法 连续测试是否可以进入临界区 称为忙等待</li><li>Peterson解法</li><li>TSL指令</li><li>睡眠与唤醒</li><li>生产者-消费者问题 sleep和wakeup</li><li>信号量：取值可以为0(表示未保存的唤醒操作)或者为正值(表示有一个或多个唤醒操作)</li><li>down和up</li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><ul><li> 先来先服务</li><li> 最短作业优先</li><li> 最短剩余时间优先<h3 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h3></li><li> 轮转调度</li><li> 优先级调度</li><li> 多级队列</li><li> 最短进程优先</li><li> 保证调度：-n个用户登录，每个用户获得1/n的CPU处理时间，在一个有n个进程的单用户系统中，若所有进程等价，每个进程获得1/n CPU处理时间</li><li>实现：跟踪每一个进程的CPU使用时间，CPU处理使用占比最低的进程直至占比不为最低，然后CPU处理下一个最低的进程</li><li>彩票调度：为进程提供各种系统资源的彩票，一旦需要做出一项调度决策时，就随机抽取一张彩票，拥有该彩票的进程获得资源，可以给重要的进程额外的彩票。<br>即优先级为f表示拥有彩票f份额的进程大约会获得f份额的系统资源。</li><li>即使某进程只有一张彩票，经过多轮迭代，他总会获得 CPU 的使用权。所以饥饿的问题就能解决</li><li> 公平分享调度</li></ul><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><h4 id="硬实时-必须满足绝对的截止时间"><a href="#硬实时-必须满足绝对的截止时间" class="headerlink" title="硬实时-必须满足绝对的截止时间"></a>硬实时-必须满足绝对的截止时间</h4><h4 id="软实时-可以容忍"><a href="#软实时-可以容忍" class="headerlink" title="软实时-可以容忍"></a>软实时-可以容忍</h4><h3 id="进程和线程的切换比较"><a href="#进程和线程的切换比较" class="headerlink" title="进程和线程的切换比较"></a>进程和线程的切换比较</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存分配算法-基于位图的存储管理"><a href="#内存分配算法-基于位图的存储管理" class="headerlink" title="内存分配算法-基于位图的存储管理"></a>内存分配算法-基于位图的存储管理</h3><p>提供固定大小的内存区记录内存使用情况：在决定将一个占k个分配单元的进程调入内存，存储管理器在位图中查询有k个连续为0（0表示空闲，1表示占用）的串<br>找不到连续的分配单元返回分配失败信息或者开辟新空闲区</p><h3 id="内存分配算法-基于链表的存储管理"><a href="#内存分配算法-基于链表的存储管理" class="headerlink" title="内存分配算法-基于链表的存储管理"></a>内存分配算法-基于链表的存储管理</h3><ol><li>首次适配</li><li>下次适配（从上次分配内存的地址开始查询）</li><li>最佳适配（搜索整个链表）</li><li>最差适配(总是分配最大的可用空间)</li><li>快速适配(为常用大小的空闲区维护单独的链表)</li></ol><p><strong>查询有效空间耗时最多</strong></p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>解决程序运行需要内存大于实际物理内存的问题</p><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p><strong>程序运行并不需要全部加载进内存中</strong><br>每个程序拥有自己的地址空间，该空间被分割成多块，每一块称为页或页面。</p><p>每一页都有连续的地址范围，这些页被映射到物理空间</p><p>当程序引用到一部分在物理内存中的地址空间时，由硬件执行映射，不在物理内存时，由操作系统将缺失部分装入物理内存</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>得到更多的线性空间<br> 虚拟地址空间被划分的单元为<strong>页面（page）</strong> 物理地址为<strong>页框（page frame）</strong> 大小相同，实际系统中为512B~1GB，<br>映射过程：<br><img src="/img/os/1.jpg"></p><h4 id="虚拟地址到物理地址的映射-页表"><a href="#虚拟地址到物理地址的映射-页表" class="headerlink" title="虚拟地址到物理地址的映射-页表"></a>虚拟地址到物理地址的映射-页表</h4><p>虚拟地址分为虚拟页号和偏移量</p><p>页表的目的是将虚拟页面映射为页框，虚拟页面的<strong>页号</strong>作为页表索引找到该虚拟页面的页表项</p><p>再将页表项的<strong>页框号</strong>拼接到偏移量的高位端，<strong>替换虚拟页号</strong>，形成送往内存的<strong>物理地址</strong></p><p>页表项结构：<br><img src="/img/os/2.jpg"></p><ol><li>保护位：三位分别表示读写执行</li><li>高速缓存禁止位：对等待I/O设备响应 确保硬件是不断从设备中读取数据而不是访问缓存中的旧数据</li><li>访问位和修改位 页面被修改必须写回磁盘，未修改直接丢弃（导入内存的是磁盘数据的副本）<h4 id="解决虚拟地址到物理地址的映射速度匹配"><a href="#解决虚拟地址到物理地址的映射速度匹配" class="headerlink" title="解决虚拟地址到物理地址的映射速度匹配"></a>解决虚拟地址到物理地址的映射速度匹配</h4></li></ol><ul><li> 将这个页表导入内存</li><li> 转换检测缓冲区-设置快表</li><li> 软件TLB管理<h4 id="处理页表过大问题"><a href="#处理页表过大问题" class="headerlink" title="处理页表过大问题"></a>处理页表过大问题</h4></li></ul><ol><li>多级页表</li><li>倒排页表-实际内存中每一个页框对应一个页表项，而不是虚拟内存对应一个页表项<br>并将页框与与之对应的虚拟页面链接形成散列表。<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4>R:访问位，M：修改位</li></ol><ul><li> 最优页面置换算法</li><li> 最近未使用页面置换算法</li><li> 先进先出页面置换算法</li><li> 第二次机会页面置换算法-避免先进先出将经常访问的页面替换出去</li><li> 修改：检查最老的页面的R位，如果是0，表示该页面最老且未访问，可以立即置换，否则将R位清0 修改装入时间并放于链表队尾</li><li> 时钟页面置换算法-弥补第二次机会页面置换算法经常在链表中移动页面的效率问题</li></ul><p> <img src="/img/os/3.jpg"></p><ul><li> 最近最少（LRU）使用页面置换算法</li><li> 老化算法</li><li> 工作集算法-找出一个不在工作集中的页面并淘汰</li><li>一个进程当前正在使用的页面集合称为工作集</li><li>在进程运行时预先调页<br><img src="/img/os/5.jpg"></li><li>最坏情况，所有页面都被访问过了最好选择一个未修改的页面</li><li> 工作集时钟算法<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(R==<span class="hljs-number">1</span>)&#123;<br>R=<span class="hljs-number">0</span>;<br>move next page;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>&#123;<br><span class="hljs-keyword">if</span>(T&gt;τ&amp;&amp;m==<span class="hljs-number">0</span>)change page;<span class="hljs-comment">//T为page在内存中的生存时间，τ为最长生存时间，m为修改位</span><br><span class="hljs-keyword">if</span>(m==<span class="hljs-number">1</span>)&#123;<br><br>判断是否将修改页面写回磁盘(一次写操作)，写回则将m位修改为<span class="hljs-number">0</span>;<br>move next page;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>如果指针经过<strong>一圈</strong>返回起点:</li></ul><ol><li>若有至少一次写操作，则不断循环必然有一个干净页面</li><li>无写操作，随便选择一个干净页面替换并记录位置，或者选定当前页将其写回磁盘。<h4 id="补充页面大小"><a href="#补充页面大小" class="headerlink" title="补充页面大小"></a>补充页面大小</h4>进程平均为s字节，页面大小为p字节，每个页表项e个字节</li></ol><ul><li> 每个进程页数 s/p 页表空间 se/p 内部碎片平均为 p/2;</li><li> 开销=se/p+p/2;</li><li> 最优p=√2se  <h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3>在编译器编译过程中，多个表会以不可预知的方式增加或减少，地址空间分给某些表的空间已被装满，而某些表仍有的大量空间<br>编译过程可能会创建的表：</li></ul><ol><li>源程序正文</li><li>符号表，包含变量的名字和属性</li><li>包含所有整型量和符号常量的表</li><li>语法分析树，包括程序语法分析的结果</li><li>编译器内部调用使用的堆栈<br>需求：能令程序员不用管理表扩张和收缩的办法<h4 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h4></li></ol><p><strong>将程序和数据可被划分为逻辑上独立的地址空间并有助于共享和保护</strong><br>将同一类型或属于同一逻辑实体的分为一个段，每个段构成一个独立空间，可以独立增长或减少而不影响其他段。<br>再次编译也不需要修改未改变的段</p><h3 id="段页结合"><a href="#段页结合" class="headerlink" title="段页结合"></a>段页结合</h3><p>虚拟地址(位数划分以具体系统为准)：<br><img src="/img/os/4.jpg"></p><p>查询算法流程：</p><ol><li>根据段号找到段描述符</li><li>检查该段是否在内存中，在就寻找，不在产生段错误，如果违反段保护要求就发出越界错误</li><li>检查所请求虚拟页面的页表项，如果不在内存就产生一个缺页中断，在就从页表项中取出该页面在内存中的起始位置</li><li>把偏移量加到页面的起始位置，得到要访问的字在内存中的地址</li><li>进行读或写操作<br><img src="/img/os/6.jpg"></li></ol><h3 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h3><ol><li>硬件陷入内核，在堆栈保存程序计数器。大多数机器将当前指令的各种状态信息保存在特殊的CPU中</li><li>启动一个汇编代码保存通用寄存器和其他易失信息</li><li>当操作系统发现一个缺页中断时，尝试发现需要哪个虚拟页面</li><li>获得发生缺页中断的虚拟地址，操作系统检查地址有效性，并检查存取和保护是否一致，不一致，向进程发送信息或杀死进程。</li></ol><p>如果地址有效，系统检查有无空闲页框，如果没有，执行页面置换算法<br>5. 如果选择的页面“脏”了，安排该页面写回磁盘，并发生一次上下文切换，挂起发生缺页中断的进程，让其他进程执行至写回结束，同时将该页框标记为忙，避免被其他执行的进程占用<br>6. 一旦页框“干净” 操作系统查找所需页面的地址并装入，装入过程中该进程仍被挂起，由其他进程执行。<br>7. 当磁盘中断发生后，表明该页面已经被装入，页框标记为正常<br>8. 恢复发生缺页中断之前状态，程序计数器重新指向之前的指令<br>9. 恢复寄存器和其他状态信息，返回用户空间继续执行。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="TCP和UDP的比较"><a href="#TCP和UDP的比较" class="headerlink" title="TCP和UDP的比较"></a>TCP和UDP的比较</h2><table><thead><tr><th>类型</th><th>是否面向连接</th><th>传输可靠性</th><th>传输形式</th><th>传输效率</th><th>需要资源</th><th>应用场景</th></tr></thead><tbody><tr><td>TCP</td><td>面向连接</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>要求通信数据可靠</td></tr><tr><td>UDP</td><td>无连接</td><td>不可靠</td><td>数据报文段</td><td>快</td><td>少</td><td>要求传输速度快</td></tr></tbody></table><h2 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h2><ol><li><strong>数据</strong>被分成若干TCP报文段</li><li><strong>TCP报文段</strong>首部包含32比特的序号字段和确认号字段。</li></ol><ul><li>序号字段：TCP隐式地对数据流中的每一个字节编号</li><li>确认字段：填充期望收到的下一字节号</li><li>TCP对确认的字段采取累积确认的方法</li><li>对失序的报文段进行保留而不是直接丢弃</li></ul><ol start="3"><li><strong>超时重传</strong></li></ol><ul><li>超时重传的时间间隔设置：TimeoutInterval=EstimatedRTT+4*DevRTT<ol><li>估算RTT 某一时刻测量报文段的RTT称为SampleRTT 其加权平均值为</li></ol>  EstimatedRTT=（1-α）* EstimatedRTT+α * SampleRTT （α一般为1/8)<ol start="2"><li>估算RTT的变化 DevRTT=（1-β）* DevRTT+β * |SampleRTT-EstimatedRTT|（β一般为1/4)</li></ol></li><li>定时器 使用单一的重传定时器</li><li>定时器启动条件：<ol><li>发送报文段且定时器未启动 </li><li>定时器超时重启，时间间隔翻倍 </li><li>收到ack</li></ol></li></ul><ol start="4"><li><strong>流量控制</strong> 流量控制服务是一个速度匹配服务，用于消除接收方缓存溢出的可能性</li></ol><ul><li>接收方维护一个接收缓存 大小为RcvBuffer</li><li>LastByteRead 接收端的应用进程从缓存中读取的最后一个字节的编号</li><li>LastByteRcvd 从网络中到达并由接收方接收的最后一个字节的编号</li><li>LastByteRcvd-LastByteRead≤RcvBuffer rwnd=RcvBuffer-（LastByteRcvd-LastByteRead）</li><li>发送方维护跟踪两个变量：LastByteSent 最后发送的字节编号 LastByteAcked 最后被确认的字节编号</li><li>LastByteSent-LastByteAcked≤rwnd</li><li>当rwnd=0时，发送方继续发送只有一个字节的数据，接收方返回确认报文</li></ul><p><img src="/img/network/1.jpg" alt="1"></p><ol start="5"><li><strong>拥塞控制</strong> 根据网络的拥塞情况而调整发送速度</li></ol><ul><li><p>端到端的拥塞控制：超时或3次冗余确认</p></li><li><p>网络辅助拥塞控制：路由器向发送方显示反馈网络拥塞状况</p><h3 id="如何限制发送速率，如何感知网络拥塞-如何改变发送速率"><a href="#如何限制发送速率，如何感知网络拥塞-如何改变发送速率" class="headerlink" title="如何限制发送速率，如何感知网络拥塞 如何改变发送速率"></a>如何限制发送速率，如何感知网络拥塞 如何改变发送速率</h3><ol><li><p>如何限制 LastByteSent-LastByteAcked≤min{cwnd,rwnd} (cwnd为发送方拥塞窗口大小)</p></li><li><p>如何感知 超时或3个冗余ACK</p></li><li><p>如何调整 TCP拥塞控制算法</p><p> 3.1  慢启动 指数增长</p><p> 3.2  拥塞避免 达到cwnd/2阈值 线性增长</p><p> 3.3  快恢复 </p></li></ol></li></ul><ol start="6"><li>差错恢复机制 TCP采取累积确认方式，接受方不会对正确但失序的报文段逐个确认</li></ol><h3 id="流水线的差错控制"><a href="#流水线的差错控制" class="headerlink" title="流水线的差错控制"></a>流水线的差错控制</h3><h4 id="回退N步（GBN"><a href="#回退N步（GBN" class="headerlink" title="回退N步（GBN)"></a>回退N步（GBN)</h4><h5 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h5><ol><li>累积确认</li><li>丢弃所有失序分组<h5 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h5></li><li>超时重传所以已发送但还未确认的分组<h4 id="选择重传（SR）"><a href="#选择重传（SR）" class="headerlink" title="选择重传（SR）"></a>选择重传（SR）</h4><h5 id="接收方-1"><a href="#接收方-1" class="headerlink" title="接收方"></a>接收方</h5></li><li>逐个确认分组，失序分组进行缓存处理<h5 id="发送方-1"><a href="#发送方-1" class="headerlink" title="发送方"></a>发送方</h5></li><li>一分组一确认<h2 id="浏览器输入url地址回显页面过程"><a href="#浏览器输入url地址回显页面过程" class="headerlink" title="浏览器输入url地址回显页面过程"></a>浏览器输入url地址回显页面过程</h2><table><thead><tr><th>过程</th><th>协议</th></tr></thead><tbody><tr><td>浏览器查询域名的IP地址</td><td>DNS：获取域名对应IP</td></tr><tr><td>浏览器向web服务器发送一个http请求</td><td>TCP，IP,OPSF,ARP,HTTP</td></tr><tr><td>服务器处理请求</td><td></td></tr><tr><td>服务器返回一个html响应</td><td></td></tr><tr><td>浏览器回显html</td><td></td></tr></tbody></table></li></ol><h2 id="应用层：DNS"><a href="#应用层：DNS" class="headerlink" title="应用层：DNS"></a>应用层：DNS</h2><p>DNS提供将主机名转换为IP地址的目录服务，运行于UDP协议，端口为53号</p><h3 id="DNS服务器分类："><a href="#DNS服务器分类：" class="headerlink" title="DNS服务器分类："></a>DNS服务器分类：</h3><ul><li>根DNS服务器</li><li>顶级域DNS服务器</li><li>权威DNS服务器</li><li>本地服务器</li></ul><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><ol><li><p>递归：客户端只发一次请求，要求对方给出最终结果。</p></li><li><p>迭代：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，</p></li></ol><p>客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。<br>图示：<br><img src="/img/network/2.jpg"></p><p>3.实践中：从请求主机到本地DNS服务器是递归，其余查询是迭代的<br><img src="/img/network/3.jpg"></p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="数据平面-转发"><a href="#数据平面-转发" class="headerlink" title="数据平面-转发"></a>数据平面-转发</h3><p>作用：从其输入链路向其输出链路转发数据报</p><h4 id="IPv4协议"><a href="#IPv4协议" class="headerlink" title="IPv4协议"></a>IPv4协议</h4><h5 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h5><p>IP首部各字段：<br><img src="/img/network/4.jpg"><br>部分关键字段解释：</p><ul><li>版本号：规定IP协议版本</li><li>数据报长度：IP数据报总长度，理论长度为65535字节，实际小于等于1500字节</li><li>标识，标志，片偏移：与IP分片有关</li><li>生存时间：避免数据报在网络中永远循环，TTL减为0，数据报丢弃</li></ul><h5 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h5><ol><li>标识号：若路由器将一个数据报分为若干片时，接收端通过标识号判断哪些分片实际属于同一较大的数据报</li><li>标志：发送端将最后一个数据报的标志设为0，其余设为1<h3 id="控制平面-路由选择"><a href="#控制平面-路由选择" class="headerlink" title="控制平面-路由选择"></a>控制平面-路由选择</h3><h4 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h4></li><li>集中式路由选择算法-具有全局状态信息的算法被称作链路状态算法</li><li>Dijkstra算法</li><li>分散式路由选择算法，以迭代，分布式的方式计算最低开销路径</li><li>bellman-ford算法</li></ol><h4 id="自治系统（AS-内的路由选择协议-OSPF"><a href="#自治系统（AS-内的路由选择协议-OSPF" class="headerlink" title="自治系统（AS)内的路由选择协议-OSPF"></a>自治系统（AS)内的路由选择协议-OSPF</h4><ol><li>链路协议，洪泛链路状态信息和Dijkstra算法</li><li>优点</li><li>安全-能够鉴别OSPF路由器之间的交换</li><li>多条相同开销路径-</li><li>对单播和多播路由选择的综合支持</li><li>支持在单个AS中的层次结构-一个OSPF能够层次化地配置多个区域</li></ol><h4 id="AS之间的路由选择-BGP"><a href="#AS之间的路由选择-BGP" class="headerlink" title="AS之间的路由选择-BGP"></a>AS之间的路由选择-BGP</h4><ol><li>分布式和异步的协议</li><li>实现方式</li><li>从邻居AS获取前缀的可达性信息</li><li>确定到该前缀的”最好”路由<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="链路层寻址"><a href="#链路层寻址" class="headerlink" title="链路层寻址"></a>链路层寻址</h3><h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4></li><li>主机或路由器的适配器具有链路层地址而不是主机或路由器本身。<br>具有多个网络接口的主机或路由器将具有多个链路层地址</li><li>接受帧：</li><li>发送适配器将目的适配器的MAC地址插入该帧，并将该帧广播到局域网中，<br>局域网中各适配器接受并对比MAC地址，相同向上传递，不同则丢弃</li></ol><h4 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议-ARP"></a>地址解析协议-ARP</h4><ol><li>ARP为在同一子网内的主机和路由器接口解析IP地址</li><li>如何工作</li><li>每个主机或路由器在其内存中都有一个IP到MAC映射关系的ARP表<br>主机222.222.222.220一个可能的ARP表(TTL:该映射关系的时长，一般为20分钟)<table><thead><tr><th>IP地址</th><th>MAC地址</th><th>TTL</th></tr></thead><tbody><tr><td>222.222.222.221</td><td>88-B2-2f-54-1A-0F</td><td>13.45.00</td></tr><tr><td>222.222.222.223</td><td>5C-66-AB-90-75-B1</td><td>13.52.00</td></tr></tbody></table></li><li>主机向局域网广播目的主机的MAC地址，发送帧上插入下一跳的MAC地址</li></ol><h2 id="TCP连接-三次挥手和四次挥手"><a href="#TCP连接-三次挥手和四次挥手" class="headerlink" title="TCP连接-三次挥手和四次挥手"></a>TCP连接-三次挥手和四次挥手</h2><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><ol><li>客户端的TCP向服务端的TCP发送一个特殊的TCP报文</li><li>不包含应用层数据</li><li>报文段首部标志位（SYN）设为1，并选择一个起始序号seq=client_isn</li><li>服务端接收到报文并发送SYNACK报文</li><li>提取TCP SYN报文段，为该TCP连接分配TCP缓存和变量</li><li>SYN设为1，确认号字段ack=client_isn 起始序号 seq=server_isn</li><li>客户端接收报文后</li><li>客户端分配TCP缓存和变量，连接建立，以后SYN标志号设为0</li></ol><h3 id="TCP关闭"><a href="#TCP关闭" class="headerlink" title="TCP关闭"></a>TCP关闭</h3><ol><li>客户端发送一个特殊的TCP报文段，FIN设为1</li><li>服务器接收后发送一个确认报文段，然后服务器发送终止报文段</li><li>客户端发送确认报文段，连接终止</li></ol><p>客户端状态：<br><img src="/img/network/5.jpg"></p><p>服务器端状态：<br><img src="/img/network/6.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>暑假总结</title>
    <link href="/2021/09/22/%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93/"/>
    <url>/2021/09/22/%E6%9A%91%E5%81%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="暑假总结"><a href="#暑假总结" class="headerlink" title="暑假总结"></a>暑假总结</h1><p>大二升大三的暑假最后一天，没有疫情的话，8月15号就要开学实训的，然而南京突发疫情导致开学日期延至9月23号，总之又获得了一个漫长的暑假<br>明年暑假大概率是不回来了，或者考研或者实习，<br>中秋到现在已经放了自己四天了。想到今天是暑假最后一天，复盘一下自己的假期生活。<br>总结一下暑假的学习内容，总体还是没有达到预期的目标   <del>还是自己对自己要求太低</del></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>学习了spring+springMVC+Mybatis SSM框架 以及 springboot部分内容<br>并完成了一个ssm整合的小demo和仿天猫商城的ssm项目</p><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>跟着力扣刷题手册和代码随想录刷了200+的题，包括数组，回溯，排序，双指针，贪心，动归和二叉树</p><p>目前全部实现代码提交在github的<a href="https://github.com/nbyxs/LeetCode">LeetCode仓库</a></p><h2 id="项目整理"><a href="#项目整理" class="headerlink" title="项目整理"></a>项目整理</h2><ul><li>ssm的crud小demo</li><li>仿天猫官网的<a href="https://how2j.cn/k/tmall_ssm/tmall_ssm-1399/1399.html?p=187608">ssm项目</a></li><li>实训的<a href="https://github.com/LviatYi/AspirineManager">医药管理系统</a> （简单的页面跳转+crud，并且采用JWT进行身份验证，不过前端写的非常烂，<del>是的，就是我写的</del>，主要是学会了团队协作开发以及git的基本使用)</li></ul><h2 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h2><ol><li>《计算机网络自顶向下》 看到第四章 网络层 啃不动了，</li><li>《算法》 第四版 结合刷题选择性的看，看了排序，二叉树等章节</li><li>《二战历史年记》才看了前三章 23333</li></ol><h2 id="博客学习"><a href="#博客学习" class="headerlink" title="博客学习"></a>博客学习</h2><ul><li><a href="https://snailclimb.gitee.io/">JavaGuide的博客及面试整理</a><ul><li><pre><code>熟悉了java基础+集合+多线程</code></pre></li><li><pre><code>了解了JVM</code></pre></li><li><pre><code>复习了操作系统+计算机网络</code></pre></li><li><pre><code>了解了数据库事务和索引等内容</code></pre></li><li><pre><code>巩固spring框架的知识</code></pre></li></ul></li></ul><h2 id="下阶段的计划："><a href="#下阶段的计划：" class="headerlink" title="下阶段的计划："></a>下阶段的计划：</h2><ol><li>完成springboot以及redis学习，并完成在线教育的项目</li><li>复习刷过的题目，继续看面经</li><li>尝试找实习，寒假之前找不到就准备考研了</li><li>努力养成看书的习惯，大部头确实难啃，也许人与人的区分度就在这上面了。道理懂得都懂，实践就是另外一回事了。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>感谢我爸妈在我整个暑假基本宅在家里也没什么怨言 <del>虽然我也有做饭什么的，嘻嘻</del> 以后也许会离家的时间会越来越长，不太会有如此长的时间陪伴父母。</p><p>自认为并不是一个好学生，可能是周围环境没有压力，宛如温水煮青蛙，学习的动力只能靠自己自觉或ddl的临近。这样噩噩浑浑了两年，感觉自己学了点，但又不知道学了什么，更不知道学了怎么用。</p><p>这不是一个好现象，而且我认为这种现象在同龄人中不在少数。临近毕业才发现自己玩了四年，步入社会而没有准备好，随着潮流考公考研，想得很多却做得很少</p><p>一句话：”我没有准备好。”</p><p>当重拾起来的时候，发现面对庞大的知识体系无从下手，力不从心，最终无功而返，功败垂成，折戟沉沙或功败垂成，前功尽弃。却不曾想自己是在偿还四年欠下的债。</p><p>间接性踌躇满志，持续性混吃等死是人的通病。</p><p>知识学的越来越多，越感觉自己的渺小，越发战战兢兢，如履薄冰，如临深渊。</p><p>学习是终生的事情，懒惰是人的天性，也许换句话说 人的一生就是和懒惰抗争的一生？</p><p>认清现实，抛弃幻想，努力奋斗。</p><p>暂时扯这么多，以后想到的再补充吧。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring</title>
    <link href="/2021/09/18/spring/"/>
    <url>/2021/09/18/spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是 Spring仍然可以和其他的框架无缝整合。</p><h2 id="spring特征：轻量，控制反转，面向切面，容器，框架"><a href="#spring特征：轻量，控制反转，面向切面，容器，框架" class="headerlink" title="spring特征：轻量，控制反转，面向切面，容器，框架"></a>spring特征：轻量，控制反转，面向切面，容器，框架</h2><ul><li>控制反转（IOC）：控制反转原则（或DI，依赖注入）<br>  在此过程中，对象仅通过构造函数参数、工厂方法参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖项(即它们使用的其他对象)；<br>  从根本上说，这个过程是bean本身通过直接构造类或Service Locator模式等机制来控制依赖项的实例化或位置的相反过程(因此得名“控制反转”)。</li></ul><h2 id="spring核心组件："><a href="#spring核心组件：" class="headerlink" title="spring核心组件："></a>spring核心组件：</h2><p><img src="spring_files/1.jpg"></p><h2 id="spring常用模块："><a href="#spring常用模块：" class="headerlink" title="spring常用模块："></a>spring常用模块：</h2><p><img src="spring_files/2.jpg"></p><h2 id="spirng-IOC原理"><a href="#spirng-IOC原理" class="headerlink" title="spirng IOC原理"></a>spirng IOC原理</h2><p>spring IoC实现原理是工厂模式+反射机制</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务与索引整理</title>
    <link href="/2021/09/17/sql/"/>
    <url>/2021/09/17/sql/</url>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><p><strong>事务</strong>（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，<br>即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。<br>如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</p><h3 id="ACID事务特性："><a href="#ACID事务特性：" class="headerlink" title="ACID事务特性："></a>ACID事务特性：</h3><p>1、原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。<br>2、一致性或可串性：事务的执行使得数据库从一种正确状态转换成另一种正确状态<br>3、隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务<br>4、持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>√</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）</p><h3 id="并发事务可能带来的问题"><a href="#并发事务可能带来的问题" class="headerlink" title="并发事务可能带来的问题"></a>并发事务可能带来的问题</h3><p>1.<strong>脏读</strong>：事务对数据进行修改但未提交至数据库，另一个事务访问同一数据称为脏数据，依据该数据进行的操作可能是不正确的<br>2.<strong>丢失修改</strong>：两个事务同时对同一数据进行修改操作，第二个事务的修改结果可能会覆盖第一个事务的结果，造成修改数据错误<br>3.<strong>不可重复读</strong>：在一个事务多次访问同一数据的期间，另一个并发事务访问该数据并进行修改，可能导致该事务多次访问的数据不同<br>4.<strong>幻读</strong>：在一个事务多次查询特定记录期间，另一个并发事务插入了几条记录，可能导致该事务多次查询结果不相同</p><h3 id="大表优化方式："><a href="#大表优化方式：" class="headerlink" title="大表优化方式："></a>大表优化方式：</h3><ul><li>1.字段：<ul><li>1.1尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</li><li>1.2VARCHAR的长度只分配真正需要的空间</li><li>1.3使用枚举或整数代替字符串类型</li><li>1.4尽量使用TIMESTAMP而非DATETIME，</li><li>1.5单表不要有太多字段，建议在20以内</li><li>1.6避免使用NULL字段，很难查询优化且占用额外索引空间</li><li>1.7用整型来存IP</li></ul></li></ul><p>2.限定数据范围<br>3.读写分离：主库负责写，从库负责读<br>4.垂直分区：将数据表列拆分<br>5.水平分区：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</p><h3 id="简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别"><a href="#简述在-MySQL-数据库中-MyISAM-和-InnoDB-的区别" class="headerlink" title="简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别"></a>简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别</h3><ul><li>MyISAM： <ul><li>1.不支持事务，但是每次查询都是原子的；</li><li>2.支持表级锁，即每次操作是对整个表加锁；</li><li>3.存储表的总行数； </li><li>4.一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；</li><li>5.采用非聚集索引，索引文件的数据域存储指向数据文件的指针。</li><li>6.辅索引与主索引基本一致，但是辅索引不用保证唯一性。 </li></ul></li><li>InnoDb：<ul><li>1.支持 ACID 的事务，支持事务的四种隔离级别；</li><li>2.支持行级锁及外键约束：因此可以支持写并发；</li></ul></li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h3 id="索引的目的是什么？"><a href="#索引的目的是什么？" class="headerlink" title="索引的目的是什么？"></a>索引的目的是什么？</h3><p>1.快速访问数据表中的特定信息，提高检索速度<br>2.创建唯一性索引，保证数据库表中每一行数据的唯一性。<br>3.加速表和表之间的连接<br>4.使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间</p><h3 id="索引对数据库系统的负面影响是什么？"><a href="#索引对数据库系统的负面影响是什么？" class="headerlink" title="索引对数据库系统的负面影响是什么？"></a>索引对数据库系统的负面影响是什么？</h3><p>负面影响：<br><strong>创建</strong>索引和维护索引需要耗费时间，这个时间随着<strong>数据量</strong>的增加而增加；<br>索引需要占用<strong>物理空间</strong>，不光是表需要占用数据空间，每个索引也需要占用物理空间；<br>当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。</p><h3 id="为数据表建立索引的原则有哪些？"><a href="#为数据表建立索引的原则有哪些？" class="headerlink" title="为数据表建立索引的原则有哪些？"></a>为数据表建立索引的原则有哪些？</h3><p>在最频繁使用的、用以缩小查询范围的字段上建立索引。<br>在频繁使用的、需要排序的字段上建立索引</p><h3 id="什么情况下不宜建立索引？"><a href="#什么情况下不宜建立索引？" class="headerlink" title="什么情况下不宜建立索引？"></a>什么情况下不宜建立索引？</h3><p>对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。<br>对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="什么是乐观锁"><a href="#什么是乐观锁" class="headerlink" title="什么是乐观锁"></a>什么是乐观锁</h3><p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；<br>悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，</p><h4 id="乐观锁的实现方式："><a href="#乐观锁的实现方式：" class="headerlink" title="乐观锁的实现方式："></a>乐观锁的实现方式：</h4><p><strong>版本号</strong>：给数据增加一个版本标识，在数据库上就是表中增加一个version字段，<br>每次更新把这个字段加1，读取数据的时候把version读出来，更新的时候比较version，如果还是开始读取的version就可以更新了，<br>如果现在的version比老的version大，说明有其他事务更新了该数据，并增加了版本号，<br>这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理<br><strong>时间戳</strong>（timestamp）：和版本号基本一样，只是通过时间戳来判断而已，<br>注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间。<br><strong>待更新字段</strong>：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息</p><h3 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁"></a>什么是悲观锁</h3><p>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，</p><h4 id="悲观锁按性质分："><a href="#悲观锁按性质分：" class="headerlink" title="悲观锁按性质分："></a>悲观锁按性质分：</h4><p>排他锁（x锁）：事务A对对象T加s锁，其他事务也只能对T加S，多个事务可以<strong>同时读</strong>，但<strong>不能有写操作</strong>，直到A释放S锁。<br>共享锁（s锁）：事务A对对象T加X锁以后，其他事务<strong>不能对T加任何锁</strong>，只有事务A可以读写对象T直到A释放X锁。<br>更新锁（u锁）：用来预定要对此对象施加X锁，它<strong>允许其他事务读</strong>，但<strong>不允许再施加U锁或X锁</strong>；当被读取的对象将要被更新时，则升级为X锁，主要是用来防止死锁的</p><h3 id="什么是自旋锁"><a href="#什么是自旋锁" class="headerlink" title="什么是自旋锁"></a>什么是自旋锁</h3><p>自旋锁原理非常简单，<br>如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，<br>它们只需要等持有锁的线程释放锁后即可立即获取锁，<br>这样就避免用户线程和内核的切换的消耗。</p><h3 id="什么是行级锁"><a href="#什么是行级锁" class="headerlink" title="什么是行级锁"></a>什么是行级锁</h3><p>行级锁是一种排他锁，防止其他事务修改此行；在使用以下语句时， Oracle 会自动应用行级锁：</p><ol><li>INSERT、 UPDATE、 DELETE、 SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT];</li><li>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新</li><li>使用 COMMIT 或 ROLLBACK 语句释放锁。</li></ol><h3 id="什么是表级锁"><a href="#什么是表级锁" class="headerlink" title="什么是表级锁"></a>什么是表级锁</h3><p>表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。<br>最常使用的MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 </p><h3 id="什么是页级锁"><a href="#什么是页级锁" class="headerlink" title="什么是页级锁"></a>什么是页级锁</h3><p>页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。<strong>表级锁速度快，但冲突多，行级冲突少，但速度慢。</strong><br>所以取了折衷的页级，一次锁定相邻的一组记录。</p><h2 id="数据库三大范式："><a href="#数据库三大范式：" class="headerlink" title="数据库三大范式："></a>数据库三大范式：</h2><p>第一范式：<strong>属性</strong>不可分<br>第二范式：非主属性不存在对主键的<strong>部分依赖</strong><br>第三范式：非主属性不存在对主键的<strong>传递依赖</strong></p><h2 id="数据库索引："><a href="#数据库索引：" class="headerlink" title="数据库索引："></a>数据库索引：</h2><p>主键的作用：</p><p>1.可以保证实体的完整性；<br>2.能够加快数据库的操作速度；<br>3.确定数据唯一性<br>…</p><h3 id="为什么主键能加快数据库的操作速度？–-gt-为什么索引能加快数据库操作速度？"><a href="#为什么主键能加快数据库的操作速度？–-gt-为什么索引能加快数据库操作速度？" class="headerlink" title="为什么主键能加快数据库的操作速度？–&gt;为什么索引能加快数据库操作速度？"></a>为什么主键能加快数据库的操作速度？–&gt;为什么索引能加快数据库操作速度？</h3><p>在没有添加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列<br>如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，<br>也就是上面说的「B Tree/B+ Tree」结构，换句话说，就是整个表就变成了一个索引。<br><strong>主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。</strong></p><p>非聚簇索引与树结构无关，与树存放的内容有关；<br>1.data域存放的是数据记录的地址，然后以data域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。<br>2.data域保存了完整的数据记录，这个索引的key是数据表的主键，这被称为“聚簇索引（或聚集索引）”。</p><p><img src="/img/1.jpg"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/09/16/hello-world/"/>
    <url>/2021/09/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/09/09/springboot/"/>
    <url>/2021/09/09/springboot/</url>
    
    <content type="html"><![CDATA[<p><img src="springboot_files/1.jpg"></p><h1 id="配置绑定"><a href="#配置绑定" class="headerlink" title="配置绑定"></a>配置绑定</h1><h2 id="ConfigurationProperties的使用："><a href="#ConfigurationProperties的使用：" class="headerlink" title="@ConfigurationProperties的使用："></a>@ConfigurationProperties的使用：</h2><p>在pom.xml中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置pom-xml文件可能的错误："><a href="#配置pom-xml文件可能的错误：" class="headerlink" title="配置pom.xml文件可能的错误："></a>配置pom.xml文件可能的错误：</h3><p><img src="springboot_files/4.jpg"><br>仔细检查maven对应setting.xml文件从146行左右开始的mirrors是否配置正确<br>不行就将mirrors注释掉复制以下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>setting.xml位置忘记的话：</p><p><img src="springboot_files/5.jpg"><br>然后重启idea</p><h2 id="在配置文件为组件赋值，Controller从配置文件中读取数据"><a href="#在配置文件为组件赋值，Controller从配置文件中读取数据" class="headerlink" title="在配置文件为组件赋值，Controller从配置文件中读取数据"></a>在配置文件为组件赋值，Controller从配置文件中读取数据</h2><p> bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">package</span> com.springboot.bean;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><span class="hljs-comment">//需要将dept类作为组件注入ioc容器</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;dept&quot;)</span><span class="hljs-comment">//指定key的前缀</span><br><span class="hljs-comment">//prefix里面不能用驼峰写法，全部小写</span><br><span class="hljs-meta">@PropertySource(value=&quot;classpath:application.properties&quot;)</span><br><span class="hljs-comment">//可不写(只要与springboot默认配置文件相同)，springboot默认配置文件是resources/application.properties</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">dept</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String dept_name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">dept</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;dept&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, dept_name=&#x27;&quot;</span> + dept_name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">dept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String dept_name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.dept_name = dept_name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDept_name</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> dept_name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDept_name</span><span class="hljs-params">(String dept_name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dept_name = dept_name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="配置文件-application-properties（dept为自己规定的前缀，类中有构造方法及成员变量要有getset方法）"><a href="#配置文件-application-properties（dept为自己规定的前缀，类中有构造方法及成员变量要有getset方法）" class="headerlink" title="配置文件 application.properties（dept为自己规定的前缀，类中有构造方法及成员变量要有getset方法）"></a>配置文件 application.properties（dept为自己规定的前缀，类中有构造方法及成员变量要有getset方法）</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">dept.id=10<br>dept.dept_name=aaa<br></code></pre></td></tr></table></figure><p>Controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.springboot.controller;<br><br><span class="hljs-keyword">import</span> com.springboot.bean.User;<br><span class="hljs-keyword">import</span> com.springboot.bean.dept;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@EnableConfigurationProperties(dept.class)</span><span class="hljs-comment">//引导加载自动配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    dept dept;<br>    <span class="hljs-meta">@RequestMapping(&quot;/dept&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> dept  <span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(dept.toString());<br>        <span class="hljs-keyword">return</span>  dept;<br>    &#125;<br>   <br><br><br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：<br><img src="springboot_files/3.jpg"></p><p>批量注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">SpringBootApplication<br><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan</span><br><br><br><br> EnableAutoConfiguration-&gt;AutoConfigurationPackage<br><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br></code></pre></td></tr></table></figure><p>把启动类所在包下及其子包下的组件批量<strong>注册</strong>进来，在启动类以上的包不会注册。<br><img src="springboot_files/2.jpg"><br><img src="springboot_files/6.jpg"></p><p> EnableAutoConfiguration-&gt;@Import({AutoConfigurationImportSelector.class})</p><p> <img src="springboot_files/7.jpg" alt="dispatcherServlet配置"></p><p> dev-tool ctrl+f9 实现热部署<br> idea中 spring initializr 创建springboot项目</p><p> yaml文件，后缀名写yaml或yml nacos可能会出现读取不到yml的情况<br> 当三种文件路径相同时,三个文件中的配置信息都会生效，但是当三个文件中有配置信息冲突时,加载顺序是yml&gt;yaml&gt;properties<br> 这里的逻辑顺序是先加载yml-&gt;yaml-&gt;properties,后加载的自然会把先加载的数据给覆盖掉.</p><p><img src="springboot_files/8.jpg"></p><h3 id="PathVariable的使用"><a href="#PathVariable的使用" class="headerlink" title="PathVariable的使用"></a>PathVariable的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/user/&#123;id&#125;/name/&#123;name&#125;&quot;)</span><br>    <span class="hljs-comment">//PathVariable会将路径变量封装成map key value皆为String</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String,Object&gt; <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span>Integer id, <span class="hljs-meta">@PathVariable(&quot;name&quot;)</span>String name, <span class="hljs-meta">@PathVariable</span> Map&lt;String,Object&gt; uv)</span></span>&#123;<br><br>        Map&lt;String,Object&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;id&quot;</span>,id);<br>        map.put(<span class="hljs-string">&quot;name&quot;</span>,name);<br>        map.put(<span class="hljs-string">&quot;user_message&quot;</span>,uv);<br>        <span class="hljs-keyword">return</span> map;<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="springboot_files/9.jpg" alt="常用参数注解"></p><p>cookie携带session id 查询session信息<br>session.set(a,b)—&gt; jsessionid —&gt; cookie-&gt;每次发请求携带。<br>如果cookie被禁用：在路径上携带session id值<br>ur1重写: /abe;jsesssionid=×x××把cookie的值使用矩阵变量进行传递<br>springboot默认未开启矩阵变量功能<br>手动开启:原理。对于路径的处理。UrLPathHeLper进行解析。<br>removeSemicoLonContent支持矩阵变量的<br>矩阵变量必须有url路径变量<br>// boss/1;age=20/2;age=10<br>获取两个路径变量的相同id的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping( &quot; /boss/**&#123;bossId&#125;**/**&#123;empId&#125;**&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map <span class="hljs-title">boss</span><span class="hljs-params">(<span class="hljs-meta">@MatrixVariable(value = &quot;age&quot; ,pathVar = &quot;bossId&quot;)</span>Integer bossAge,</span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-meta">@MatrixVariable(value = &quot;age&quot;,pathVar = &quot;empId&quot;)</span> Integer empAge)</span></span>&#123;<br>Map&lt;String, Objects&gt; map =<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">return</span> map;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="thymeleaf使用"><a href="#thymeleaf使用" class="headerlink" title="thymeleaf使用"></a>thymeleaf使用</h3><p>1、导入组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="springboot_files/10.jpg" alt="thymeleaf文件路径默认前后缀"><br><img src="springboot_files/11.jpg" alt="链接@和$区别"></p><p>springboot访问静态资源404解决方法：</p><p><img src="springboot_files/13.jpg" alt="资源结构"></p><p> 在SpringBoot中，默认配置的/**映射到/static。就是已经默认走的是static路径</p><p>解决办法就是直接去掉/static 即可！<br>或者：直接加上：</p><p><img src="springboot_files/12.jpg" alt="修改默认静态映射"></p><h2 id="拦截器："><a href="#拦截器：" class="headerlink" title="拦截器："></a>拦截器：</h2><p>1.编写一个拦截器 implements HandlerInterceptor 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//登陆检查逻辑</span><br>        HttpSession session=request.getSession();<br>        <span class="hljs-keyword">if</span>(session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>)!=<span class="hljs-keyword">null</span>)<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        session.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;请登陆&quot;</span>);<br>        request.getRequestDispatcher(<span class="hljs-string">&quot;/&quot;</span>).forward(request,response);<span class="hljs-comment">//重定向到登录页面</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.注册到容器中，（实现WebMvcConfigurer的 addInterceptor方法）记得放行静态资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-comment">//组件添加</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> LoginInterceptor())<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>) <span class="hljs-comment">//拦截资源</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;/login&quot;</span>,<span class="hljs-string">&quot;/static/**&quot;</span>);<span class="hljs-comment">//放行登陆请求和静态资源请求</span><br><span class="hljs-comment">//spring.mvc.static-path-pattern 规定静态资源请求路径</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拦截器处理流程"><a href="#拦截器处理流程" class="headerlink" title="拦截器处理流程"></a>拦截器处理流程</h3><pre><code>springMVC记录最后一个执行的拦截器的index，处理完成之后（如视图渲染，handler方法选择完成）从该拦截器倒序执行对应的清理工作并没有用stack等数据结构实现类递归的形式任何一个拦截器的prehandle返回false 之前放行的拦截器都执行afterCompletion（清理工作）</code></pre><p><img src="springboot_files/14.jpg" alt="拦截器处理流程"></p><h3 id="文件上传："><a href="#文件上传：" class="headerlink" title="文件上传："></a>文件上传：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;exampleInputFile&quot;</span>&gt;</span>File<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleInputFile&quot;</span> &gt;</span><br><span class="hljs-comment">&lt;!--                                &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;exampleInputFile&quot; multiple&gt;</span><br><span class="hljs-comment">添加 multiple表示多文件上传--&gt;</span><br></code></pre></td></tr></table></figure><p>完整表单示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html">                        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">role</span>=<span class="hljs-string">&quot;form&quot;</span> <span class="hljs-attr">th:action</span>=<span class="hljs-string">&quot;@&#123;upload&#125;&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 方法必须是post，并要添加 enctype=&quot;multipart/form-data&quot;--&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;exampleInputEmail1&quot;</span>&gt;</span>Email address<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleInputEmail1&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter email&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;exampleInputPassword1&quot;</span>&gt;</span>username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-control&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleInputPassword1&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Password&quot;</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;form-group&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;exampleInputFile&quot;</span>&gt;</span>File<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;exampleInputFile&quot;</span> &gt;</span><br><span class="hljs-comment">&lt;!--                                &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;exampleInputFile&quot; multiple&gt;--&gt;</span><br><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;help-block&quot;</span>&gt;</span>Example block-level help text here.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>                                    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span>&gt;</span> Check me out<br>                                <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;btn btn-primary&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>contorller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/upload&quot;)</span><br>  <span class="hljs-comment">//提交表单 name与参数列表名对应就无需写 @RequestParam(&quot;email&quot;)等等</span><br>  <span class="hljs-comment">//提交文件为  @RequestPart(&quot;file)String file</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span>  String <span class="hljs-title">upload</span><span class="hljs-params">(String email,String username,</span></span><br><span class="hljs-params"><span class="hljs-function">                          MultipartFile file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      System.out.println(email+<span class="hljs-string">&quot; &quot;</span>+username+<span class="hljs-string">&quot; &quot;</span>+file);<br>      <span class="hljs-keyword">if</span>(!file.isEmpty())&#123;<br>          file.getOriginalFilename();<br>          file.transferTo(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\springboot_crud\\src\\main\\resources\\static\\images\\&quot;</span>+file.getOriginalFilename()));<br><br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;form/form_layouts&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="springboot_files/16.jpg" alt="页面输入"><br><img src="springboot_files/17.jpg" alt="consle输出"></p><h3 id="配置文件修改默认文件上传大小："><a href="#配置文件修改默认文件上传大小：" class="headerlink" title="配置文件修改默认文件上传大小："></a>配置文件修改默认文件上传大小：</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.servlet.multipart.max-file-size</span>=<span class="hljs-string">10MB</span><br><span class="hljs-comment">#单个文件大小</span><br><span class="hljs-meta">spring.servlet.multipart.max-request-size</span>=<span class="hljs-string">10MB</span><br><span class="hljs-comment">#总请求大小</span><br><span class="hljs-comment"> #修改上传文件大小，默认大小 1048576 byte=1 MB</span><br></code></pre></td></tr></table></figure><h3 id="上传文件参数解析器："><a href="#上传文件参数解析器：" class="headerlink" title="上传文件参数解析器："></a>上传文件参数解析器：</h3><pre><code>MultipartAutoConfiguration自动配置了StandardServletMultipartResolver 【标准文件上传解析器】</code></pre><h3 id="错误处理机制："><a href="#错误处理机制：" class="headerlink" title="错误处理机制："></a>错误处理机制：</h3><pre><code>    如果想显示给定状态代码的自定义HTML错误页面，可以将文件添加到/error目录中。    错误页面可以是静态HTML(也就是说，添加在任何静态资源目录下)，也可以是用templates构建的。    文件的名称应该是确切的状态码或序列掩码。(即处理404的页面就叫404.html 500的叫500.html 或处理一类状态码 页面命名为4xx.html-&gt;处理以4开头的错误)    </code></pre><p><img src="springboot_files/15.jpg" alt="页面位置"></p><h2 id="Web三大组件："><a href="#Web三大组件：" class="headerlink" title="Web三大组件："></a>Web三大组件：</h2><pre><code>//声明一个servlet 直接响应，没有经过spring拦截器@WebServlet(urlPatterns = &quot;/my&quot;)@WebListener@WebFilter(urlPatterns = &#123;&quot;/static/*&quot;&#125;)在启动类上://指定原生servlet组件位置，@ServletComponentScan(basePackages = &quot;com.example&quot;)</code></pre><p>切换web服务器：<br><img src="springboot_files/18.jpg"></p><h3 id="EnablewebMvc-全面接管"><a href="#EnablewebMvc-全面接管" class="headerlink" title="EnablewebMvc:全面接管"></a>EnablewebMvc:全面接管</h3><pre><code>1、静态资源?视图解新器?欢迎页.....全部失效</code></pre><h3 id="spiringboot整合mybaits"><a href="#spiringboot整合mybaits" class="headerlink" title="spiringboot整合mybaits"></a>spiringboot整合mybaits</h3><ol><li>导入mybaits官方starter connector必须有，连接池底层默认是hikari连接池，可不配<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml">     <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--        druid --&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;dependency&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--            &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;/dependency&gt;--&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--        mybatis springboot 整合--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>编写mapper接口</li><li>编写sql映射文件并绑定mapper接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.mapper;<br><span class="hljs-keyword">import</span> com.example.bean.Category;<br><span class="hljs-keyword">import</span> com.example.bean.CategoryExample;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Mapper;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.MatrixVariable;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-meta">@Mapper</span><br><span class="hljs-comment">//mapper注解必须要写，或者在@Autowried处写成</span><br><span class="hljs-comment">//@Autowired(required = false)</span><br><span class="hljs-comment">//CategoryMapper categoryMapper; </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CategoryMapper</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method was generated by MyBatis Generator.</span><br><span class="hljs-comment">     * This method corresponds to the database table category</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@mbg</span>.generated Sun Sep 05 12:59:03 CST 2021</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method was generated by MyBatis Generator.</span><br><span class="hljs-comment">     * This method corresponds to the database table category</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@mbg</span>.generated Sun Sep 05 12:59:03 CST 2021</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Category record)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method was generated by MyBatis Generator.</span><br><span class="hljs-comment">     * This method corresponds to the database table category</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@mbg</span>.generated Sun Sep 05 12:59:03 CST 2021</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertSelective</span><span class="hljs-params">(Category record)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method was generated by MyBatis Generator.</span><br><span class="hljs-comment">     * This method corresponds to the database table category</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@mbg</span>.generated Sun Sep 05 12:59:03 CST 2021</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;Category&gt; <span class="hljs-title">selectByExample</span><span class="hljs-params">(CategoryExample example)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method was generated by MyBatis Generator.</span><br><span class="hljs-comment">     * This method corresponds to the database table category</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@mbg</span>.generated Sun Sep 05 12:59:03 CST 2021</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Category <span class="hljs-title">selectByPrimaryKey</span><span class="hljs-params">(Integer id)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method was generated by MyBatis Generator.</span><br><span class="hljs-comment">     * This method corresponds to the database table category</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@mbg</span>.generated Sun Sep 05 12:59:03 CST 2021</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKeySelective</span><span class="hljs-params">(Category record)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method was generated by MyBatis Generator.</span><br><span class="hljs-comment">     * This method corresponds to the database table category</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@mbg</span>.generated Sun Sep 05 12:59:03 CST 2021</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateByPrimaryKey</span><span class="hljs-params">(Category record)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>或直接在启动类上标注@MapperScan(mapper类包位置)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.example.mapper&quot;)</span><br><span class="hljs-meta">@ServletComponentScan(basePackages = &quot;com.example&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootCrudApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringbootCrudApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li>在yml文件中指定mapper文件位置和配置全局配置变量 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">mybatis:<br>  mapper-locations: classpath:mybatis/mapper/*.xml<br>#sql映射文件<br>#config-location: classpath :mybatis/mybatis-config .xmL 指定全局配置文件位置<br>mybatis<br>  configuration: #指定mybatis全局配置文件中的相关配置项，取代自己创建的全局配置文件<br>    map-underscore-to-camel-case: true<br></code></pre></td></tr></table></figure></li></ol><h3 id="mybatis-plus使用"><a href="#mybatis-plus使用" class="headerlink" title="mybatis-plus使用"></a>mybatis-plus使用</h3><ol><li>导入依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Latest Version<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>定义实体类以及mapper类，然后在启动类添加@MapperScan注解或在mapper类添加@Mapper<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br><span class="hljs-comment">//BaseMapper已经实现了 crud的默认方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.example.mapper&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootCrudApplicationTests</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    CategoryMapper categoryMapper;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//log.info(categoryMapper.selectByPrimaryKey(80).toString());</span><br>        List&lt;Category&gt; list=categoryMapper.selectList(<span class="hljs-keyword">null</span>);<br>        System.out.println(list.toString());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
